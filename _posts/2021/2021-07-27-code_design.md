---
layout: post
title: 高级预言程序设计的学习笔记汇总
category: 自考计算机科学与技术
tags: [高级预言程序设计]
excerpt: 高级预言程序设计的学习笔记汇总
typora-root-url: ..
---

 

## **C语言基础知识**

**重点**

- C语言的字符集、关键字和标识符
- C语言的基本组成

### 本章知识点

1. C语言的发展和特点
2. C语言的字符集、关键字和标识符；
3. C程序的基本语句分类
4. C程序的基本组成
5. C程序的开发环境。

掌握C语言的基本组成，了解C语言的运行步骤的调试方法

**C语言特点**

> C语言允许直接对计算机硬件进行曹祖据哦，既具有高级语言的功能，又具有低级语言的功能，所以也被称为“中级语言”，可用来编写系统软件

1. **结构化语言**
   - C语言具有良好的结构化（顺序、选择、循环）语句。
   - C语言的函数是程序的基本模块，便于实现程序的模块化
2. **运算能力强大**：C语言提供三十多种运算符，表达式的种类多样。
3. **数据类型丰富**：包括整型、实型、字符型、数组型、结构体类型、指针、空类型等。
4. 具有预处理能力
5. 可移植性好
6. **程序执行效率高**：由C源程序生成目标代码的效率一般仅比汇编语言低10%~20%
7. **程序设计自由度大**：C语言的语法限制不严格，允许程序员具有自由度



### **字符集**

C语言的字符集是`ASCII`。主要包含下列四类：

1. 大小写英文字母A\~Z、a\~z  (52个)
2. 数字0、1、2、…、9  (10个)
3. 非字母、非数字的可现实字符（33个），既**键盘可输入的字符**，如：+ - “ ~ ( > 等。
4. 转义字符



### **关键字**

> 注意：所有的保留字均有小写字母组成，一旦有一个字母大写，其不再是保留字原来的含义、

**数据类型：**`char`、`double`、`enum`、`float`、`int`、`long`、`shnort`、`signed`、`struct`、`union`、`unsigned`、`void`

**控制语句：**`break`、`case`、`continue`、`default`、`do`、`else`、`for`、`goto`、`if`、`return`、`switch`、`while`

**存储类型：**`auto`、`extern`、`register`、`static`

**其他关键字：**`const`、`sizeof`、`typedef`、`volatile`



### **词汇分类**

- **常量：**C语言运行中其值不发生改变的量。例如-10、12.5等
- **标识符：**C程序中使用的变量名、函数名和标号等统称标识符
- **关键字：**由C语言规定的具有特定意义的字符串
- **运算符：**C语言用于计算的符号，如+  -  *  \
- **多行注释：**`/*注释*/`   **单行注释：**`//注释`
- **分隔符:**C语言的分隔符包括括号和空格两种



### 基础语句分类

- **数据定义语句：**用来定义程序中使用的各种能存放数据对象的名称和特性 - `int a,b,c;`
- **赋值语句：**形如`变量 = 表达式` 的语句，功能市计算表达式的值并赋予变量 -  `a = 2 ; b =3;`
- **函数调用语句：**形如`函数名(实际参数表)`的语句，功能市调用指定函数 -`a = avg*(x,y,z);`
- **表达式语句：**仅由任何表达式组成的语句 - `c = a+b;`
- **流程控制语句：**用来控制程序执行过程的语句

  - **选择控制语句：**`if() ~ else ~`   `switch`
  - **循环控制语句：**`for() ~`  `while() ~`   `do ~ while()`
  - **中止语句:** `break`
  - **继续循环语句：**`continue`
  - **返回语句:** return 
  - **无条件转移语句：** goto
- **复合语句：**用花括号括住的一组任一语句    （埋：复合语句的作用？）（填：判断后需要执行需要多条语句一起执行时，可以使用复合语句）

```c
main(){
    .....
    {......} // 复合语句。 注意：右括号后不需要加;
    ....
}


```

- **空语句：**无任何操作的语句，既只由分号组成的语句，一般在程序中用作空循环体。

  - ```c
    while(getchar() != '\n')
        ;
    /*
    这里的循环体为空语句，表示循环体什么都不做
    注意：while(getchar() != '\n');和上面程序段功能一样
    */
    ```

- **其他语句：**包含编译预处理命令、用户自定义类型语句等 - `#include "stdio.h"`



**普通的C语言例题**

- 从键盘输入两个整数，计算其乘积 （主函数实现）

```c
 #include <stdio.h> /*编译预处理命令*/
int main(void){   /*主函数*/
	int n1, n2, result; /*定义保存两个整数及其乘积的变量*/
	printf("please input the two numbers:\n"); //屏幕显示提示信息
	scanf("%d,%d", &n1, &n2); //从键盘输入两个整数并分别保存在变量n1和n2
	result = n1*n2;
	printf("the result is:%d\n", result); //输出变量result中的两个整数的乘积
	return 0; //返回
		
}
/*
please input the two numbers:
2,3
the result is:6
*/
```



- 从键盘输入两个整数，计算其乘积（多函数实现）

```c
#include <stdio.h>
int mul(n1, n2){
    return n1 * n2;
}

void main(void){   /*主函数*/
	int n1, n2, result; /*定义保存两个整数及其乘积的变量*/
	printf("please input the two numbers:\n"); //屏幕显示提示信息
	scanf("%d,%d", &n1, &n2); //从键盘输入两个整数并分别保存在变量n1和n2
	result = mul(n1, n2);
	printf("the result is:%d\n", result); //输出变量result中的两个整数的乘积
}


/*
please input the two numbers:
3,5
the result is:15
*/
```



### C程序的基本组成特点

- 函数是C程序的基本单位。每个C程序是由一个或多个函数构成。每个C程序有且仅有一个主函数，该主函数的函数名规定为main。

- 每个函数（包含主函数）的定义分为两个部分：函数首部和函数体。

  - ```c
    函数首部： 返回值的类型 函数名(类型 形式参数名, ...)
    函数体：   {
    	数据定义部分
        实现函数功能的语句串
    } 
    注意：当函数没有返回值时写void
    ```

- C程序中每个语句以“分号”作为语句的结束，“分号”是C语言的组成部分，不可以省略。但预处理命令和函数首部之后不能加分号。

  - ```C
    #include <stdio.h>  //编译预处理命令
    int main(void)   //函数首部不是一条完整的语句
    ```

- C语言本身没有输入/输出语句，而是通过调用库函数`scanf()`、`printf()`、`getchar()`、`putchar()`实现的

- C语言的任任意位置都可以加注释，注释不编译。单行注释`\\注释`  多行注释`\*注释*\`

- 程序的书写格式灵活，一行客书写多条语句，一条语句可以写在多行上，可以任意插入空格和回车。但为了程序清单层次分明、便于阅读，通常都采用缩进并对其的书写方法。一条说明一条语句占一行。使用空格或TAB缩进{}对齐。有足够的注释。有合适的空行

- C语言中主函数和其他函数的位置是任意的，但程序执行总时从主函数开始，并在主函数结束。其他函数总是通过函数调用语句被执行

- 主函数可以调用其他函数；任何其他函数都可以相互调用，但不能调用主函数。

- C程序中可以有预处理命令（例如`include`命令），通常预处理命令应放在程序的最前面。

- C语言编译系统区分字母大小写。

   

### C语言的运行步骤

![image-20210823225300195](/../assets/images/2021/2021-07-27-code_design/image-20210823225300195.png)

### C程序的调试

程序的错误分：语法错误和逻辑错误。

**语法错误**能够在编译过程中被发现并修改；

**逻辑错误**的程序往往可以顺利编译甚至执行，但执行的结果不同于预期。由于较难准确定位逻辑错误，所以程序开发环境一般都会提供程序调试工具来观察程序中各变量、寄存器等值的变化，以便发现程序中的逻辑错误。 

**调试手段：**设置断点、重启调试、停止调试、逐语句调试、逐过程调试





## 数据类型、运算符和表达式

**重点**

1. 基本数据类型常量和字符串常量的书写方法
2. 变量的定义、赋值、初始化以及使用方法
3. 基本运算符的运算规则、优先级和结合性
4. 表达式的构成规则和计算

难点

- 运算符的优先级
- 混合表达式的计算



本章小结：

1. C语言的数据类型体系和运算符体系。（了解）
2. 各种基本数据类型常量和字符串常量的书写方法（掌握）
3. 基本数据类型变量的定义、赋值、初始化方法；常量的定义、初始化方法。（掌握）
4. 基本运算符的运算规则、优先级别和结合性；构成基本类型的表达式。（掌握）
5. 表达式计算和变量赋值时的类型转换规则。（掌握） 



### C语言的数据类型及其关系图

<a href='https://github.com/sorryle/sorryle.github.io/blob/main/assets/files/file/data_type.xmind'>数据类型逻辑图文件下载</a>

![image-20210824072127517](/../assets/images/2021/2021-07-27-code_design/image-20210824072127517.png)





**C语言数据类型的说命**

1. C语言规定在使用一个数据之前，必须定义数据的类型，因为数据类型决定了数据占用内存的字节数、取值范围以及在其桑可以进行的操作等。	
   - 如：`int a = 2; // 系统会分配两个字节给变量，直到主动释放或者程序结束 - 定义好了数据类型，程序就可以知道这个变量可以使用什么方法 `
2. C语言的数据有常量和变量之分，它们分别属于上述的类型。
3. 数据类型丰富，包括整型、实行型、字符型、数组型、结构体类型、指针型和空类型等。



### **常量的基本概念**

- 常量又称为常数，是程序运行过程中其值不能改变的数据。
- C语言规定常量包括：整型常量(1)、实型常量(1.2)、字符型常量(‘t’)、字符串常量(“test”)、符号常量（埋坑：什么是符号常量）
- 使用常量时，不需要事先定义，只需要在程序中直接写出。常量的类型客通过书写形式自动识别，无需定义。



**整型常量**

- **十进制整数：**由数字0-9和正负号表示。如：`0、-111、+15、21`等
- **八进制数（以0开头）：**例如：`00、-0111、+015、021`（埋：二进制转八进制）（填：三合一法，`101110.101 = 56.5`）
- **十六进制整数（以0x开头）：**例如：`0x0、-0x111、+0xff、0x2d`

说明：

- 正整数前面的`“+”`可以省略。
- 整型常量在16位计算机中占用2个字节，数值范围位$-2^{15} ~ (2^{15}-1) = -32768~32767$
- 长整型常量(在整型的末尾加个字符`L`):
  - **例如：**`0L(十进制)`、`0111L（八进制）`、`0x15L(十六进制)`长整型常量在计算机中占用4个字节。其取值范围可达$-2^{31} ~ (2^{31} -1)$(埋坑：计算机出具体数值)
  - <font color='red'>注意：10和10L是不同的整型常量，虽然它们由相同的数值，但它们在内存中占用不同数量的字节。</font>（埋坑：为什么要这样设计，常量不会变量，为什么要占用那么多字节）（填坑：长整型的出现是为了存放计算结果，如：$10^{10}=100亿$​​​，使用i整型常量是不能装不下的，这时候可以放到长整型中）



**实型常量**

实型常量只使用十进制，它的书写形式有两种

1. 十进制数形式：（必须有小数点）如：`0.123, .123, 123.0, 0.0, -.123, 12.`
2. 指数形式：（e或E之前必须有数字;）指数必须为整数）如：`12.3e3, 123E2, 1.23e4`   **错误：**`e-5, 12.E-3.5`
   1.说明:实型常量在计算机占用4个字节，数值范围都是$-10^38 ~ 10^38$​
   2.实型常量有效数字是七位。例如，1.234567789和1.234567是相同的。（埋坑：有效数是说明）



**字符常量**

字符常量：用一对单引号前后括住的单个字符。例如，`‘a’, ‘1’, '%', 'A'`

转移字符：一种特殊形式的字符常量，以反斜杠`\`开头，后面跟单个字符或若干个字符组成。

| 符号 |              | 符号   |                                |
| ---- | ------------ | ------ | ------------------------------ |
| `\n` | 回车换行符   | `\a`   | 响铃符号                       |
| `\t` | Tab符号      | `\"`   | 双引号                         |
| `\v` | 垂直制表符   | `\'`   | 单引号                         |
| `\b` | 左退一格符号 | `\\`   | 反斜杠                         |
| `\r` | 回车符号     | `\ddd` | 1~3位进制数ddd对应的ASCII字符  |
| `\f` | 换页符号     | `\xhh` | 1~2位16进制数hh对应的ASCII字符 |
|      |              |        |                                |





**字符串常量**

- 字符串常量简称为“字符串”。字符串就是用两个双引号`“”`前后括住的一串字符。例如：`“abc”, "123", "A", "\101\n\x43"`

- 空字符串：没有字符的字符串称为**空字符串**。例如：`“”`

- 字符串的长度：一个字符串中所有字符的个数称为该字符串的长度。例如：`""`的长度为0；`“abc12c”`的长度为5；`“\101\n\x43ab”`的长度为5

说明：

- 空串与空格串是不同的。空串不含任何字符，长度为0；空格串是包含若干空格字符的字符串，其长度为所含空格字符的个数。
- 每个字符串在内存中占用的字节数等于字符串的长度+1、其中最后一个字节存放的字符为”空字符串“，其值为0，书写时常用转义字符“\0”来表示，称为字符串结束标记。例如：`“China”`  == `China\0`



**符号常量**

- 符号常量的定义方法如下：`#define 符号常量 常量`      （埋坑：定义符号常量的后，符号被赋值会发生什么）
- 例如：
  - `#define PI 3.14159  // 定义了符号常量PI，其值等于实型常量3.14159`
  - `#define R 10 // 定义了符号常量R，其值等于整型常量10`
  - `#define A 'A' //定义了符号常量A，其值等于字符常量’A‘`

说明：

- 符号常量按标识符的规则构成，建议用大写的英文字符组成。其中的常量可以时任何类型的常量
- 符号常量的定义一般放在程序的开头，每个定义必须独占一行，其后不跟分号`;`，
- 在程序中使用符号常量有两点好处：提高程序的可读性；便于程序修改





### 变量的基本概念

1. **变量：**在程序运行过程中，其值可以被改变的量称为变量 
   （埋坑：短整型变量如果放入超过长度的数会怎样）
   （埋坑：什么时候int占用字节数时2位，什么时候int占用字节数时4位）
    (埋坑：字符串的取值范围的作用。)
2. 变量的三个要素：
   - 变量名：每个变量都必须有一个名字~变量名，变量命名遵循标识符命名规则
   - 变量值：变量中所保存的数据称为该变量的值，在程序运行过程中，变量值存储在内存中。
   - 变量类型：变量类型可以时任何一种数据类型。<a href='https://github.com/sorryle/sorryle.github.io/blob/main/assets/files/file/data_type.xmind'>数据类型Xmind文件</a>

 

**变量定义和初始化**

- `数据类型符 变量名1 [,变量名2,...];`
- 说明：对变量的定义可以放在函数之外，也可以放在函数体中或复合语句中。如果时放在函数体或复合语句中，则必须集中放在最前面
  （埋坑：变量未赋值使用会怎样）
- 说明：值在-128和127之间的`int`、`short`、`long`的变量  ==  `字符型变量`
              值在0~255之间的`unsigned`、`unsigned short`、`unsigned long`的变量   == 字符型变量

```c
int r, s; //定义2个有符号基本整型变量
short m, n;  // 定义2个有符号的短整型变量
long p, q; //定义2个有符号长整型变量
unsigned i, j, k; //定义3个无符号基本整型变量
float r, s; //定义2个单进度实型变量
double f1, f2; //定义2个双精度实型变量
char c1, c2; //定义2个字符型变量，全局变量，作用域整个文件


void main(){
    int me=2; //定义在函数之内的变量，作用域只在函数内
    {int fu;
     fu = me +c1; //定义在复合语句的变量，作用域只在复合语句中
    }
}
```



```c
#include <stdio.h>

/*
说明：
值在-128和127之间的`int`、`short`、`long`的变量  ==  `字符型变量`
值在0~255之间的`unsigned`、`unsigned short`、`unsigned long`的变量   == 字符型变量
*/

void main(void){   
	char a =97;
	printf("The value of a: %c", a);
}

/*result：
The value of a: a
*/
```



**有名常量的定义**

C语言中，如果定义了变量并赋予其初值，但不希望在程序中对其值进行修改，则可以将该变量定义为又名常量。有名常量定义语句的一般格式如下：

```c
// 格式：const 数据类型 变量名1=初值1;
const int j=1;
const float f1=1.;
```









### 逻辑运算符和逻辑表达式

| 名称   | 运算符 | 对象数与位置 | 运算规则 | 对象类型       | 结果类型           | 结合性   |
| ------ | ------ | ------------ | -------- | -------------- | ------------------ | -------- |
| 逻辑非 | ！     | 单目前缀     |          | 数值型或字符型 | 逻辑值0或1（整型） | 自右向左 |
| 逻辑与 | &&     | 双目前缀     |          | 数值型或字符型 | 逻辑值0或1（整型） | 自左向右 |
| 逻辑或 | \|\|   | 双目前缀     |          | 数值型或字符型 | 逻辑值0或1（整型） | 自左向右 |

- 单目：只需要一个值就可以运算
- 双目：需要两个值才可以运算

**说明：**

1. 逻辑运算的结果是整型数0或1

2. 逻辑运算符的优先级如下：`!`优先于双目运算符 优先于 关系运算符 优先级 `&&` 优先于 `||`

3. 用`&&`对两个表达式进行计算时，若第一个表达式的值为“假”，则**运算结果与第二个表达式的值无关**，结果肯定为“假”，所以C语言规定此时<font color='red'>**第二个表达式将不再计算**</font>。例：

  ```c
  	int result,a=5;
  	result = 0&&(a++);
  	printf("results is %d\n" , result); // results is 0
  	printf("%d" , a);  // 5  值依然是5，因为第一个表达式的值为“假”用
  ```

4. 用`||`对两个表达式进行计算时，若第一个为“真”，则运算结果与**第二个表达式的值无关**，结果肯定为“真”,所以C语言规定此时<font color='red'>**第二个表达式也不再计算**</font>。例：

  ```c
  	int result,a=5;
  	result = 1||(a++);
  	printf("results is %d\n" , result); //
  	printf("%d" , a);  // 5  因为第一个表达式的值为“真”用
  ```

5. 逻辑运算符两侧的运算对象可以是任何类型的数据的，如整型、实型、字符型等。系统一律当作逻辑值进行解释，既`非0`为逻辑真; `0`为逻辑假

逻辑表达式：由逻辑运算符链接表达式构成。

```c
int x=3, y=100, result;
float f1=1.0, f2=2.1;
char c='d'; 
  
printf("result is %d of f1&&f2&&c",  f1&&f2&&c); //result is 1 of f1&&f2&&c
printf("result is %d of f1>f2||!c",  f1>f2||!c); //result is 1 of f1&&f2&&c
printf("result is %d of x+97==y&&y==c",  x+97==y&&y==c); //result is 1 of x+97==y&&y==c
```

 **实际运用的例子**

| 数学问题          | C语言的表达式                          |
| ----------------- | -------------------------------------- |
| a<b<c             | `a<b && b<c`                           |
| ch是数字字符      | `ch>='0' && ch<='9'`                   |
| ch是字符          | `ch>='A'&&ch<='Z' || ch>='a'&&ch<='z'` |
| ch是字符串结束符  | `ch=='\0'`                             |
| ch不是回车换行符  | `ch!=‘\n’`                             |
| 整型变量a中是奇数 | `a%2==1`                               |
| 整型变量a中是偶数 | `a%2==0`                               |



**复合赋值运算符**

| 名称         | 运算符 | 对象数和位置 | 运算规则              | 对象类型 | 结果类型 |
| ------------ | ------ | ------------ | --------------------- | -------- | -------- |
| 加赋值       | +=     | 双目中缀     | a+=b 相当 a=a+(b)     | 数值型   | 数值型   |
| 减赋值       | -=     | 双目中缀     | a-=b 相当 a=a-(b)     | 数值型   | 数值型   |
| 乘赋值       | `*=`   | 双目中缀     | `a*=b` 相当 `a=a*(b)` | 数值型   | 数值型   |
| 除赋值       | /=     | 双目中缀     | a/=b 相当 a=a/(b)     | 数值型   | 数值型   |
| 模赋值       | %=     | 双目中缀     | a%=b 相当 a=a%(b)     | 整型     | 整型     |
| 位与赋值     | &=     | 双目中缀     | a&=b 相当于a=a&(b)    | 整型     | 整型     |
| 位或赋值     | \|=    | 双目中缀     | a\|=b 相当于a=a&(b)   | 整型     | 整型     |
| 位异或加赋值 | ^=     | 双目中缀     | a^=b 相当于a=a&(b)    | 整型     | 整型     |
| 位左移赋值   | <<=    | 双目中缀     | a<<=b 相当于a=a&(b)   | 整型     | 整型     |
| 位右移赋值   | `>>=`  | 双目中缀     | a>>=b 相当于a=a&(b)   | 整型     | 整型     |



1. 算术复合赋值运算符的优先级如下：`算术运算符 优先于 关系运算符 优先于 双目运算符 优先于 算术复合赋值运算符`
   算术复合运赋值运算符和赋值运算符的优先级是相同的，结合性都是自右向左的。

2. 算术复合赋值运算符右边的表达式是自动加括号的。例如：`“c%=a-3” 不能理解为"c=c%a-3，应理解为"c=c%(a-3)"`

3. 赋值运算符：由赋值运算符或复合赋值运算符连接变量和表达式构成。

   ```c
   int i=1,j; float f=2.0;
   f+=i-1; // 即f=2.0+(1.1), 表达式的值是2.0，f的值2.0
   i=i>=f;  // 即i=(1>=2.0)  表达式的值是0， i的值是0
   j=!(i==1); // 即j=!(1==1), 表达式的值是0， j的值是0
   i=j=2;  // 表达式的值为2，i的值为2，j的值为2
   
   //例子1
   int m1=1,m2=10,m3=10,m4=10;
   m1+=m2-=m3*=m4/=2; //表达式的值为-30
   
   int m=10;
   m+=m-=m*m; 
   // 第一次计算错误：表达式的值为-80    10*10 -> 10-100- > (-90)+10
   // 第二次看到答案后计算：0   10*10 -> 100-100 -> 0+0 
   // 第三次思考后答案：表达式的值为-180    10*10 -> 10-100 -> -90+-90
   ```



**逗号运算符和逗号表达式**

| 运算符 | 对象数与位置 | 运算规则                 | 对象类型       | 结果类型           | 结合性   |
| ------ | ------------ | ------------------------ | -------------- | ------------------ | -------- |
| ,      | 双目中缀     | 依次计算左边、右边表达式 | 任何类型表达式 | 右边的表达式的类型 | 自左向右 |

逗号表达式：用逗号运算符把两个或多个表达式连接起来构成逗号表达式，构成规则如下：`表达式1,表达式2,...`

```c
int i=1,j; float f=2.0; char ch='b';
i+1, ch+1;  // 既1+1， 98+1 
i>ch, i>=f; // 既i>98; 1>=2.0
i=j=2, j=3 ;
// 第一次计算，i的值为2。j=3 -> j=2 -> i=2
// 第二次计算，j的值为3。  j=2 -> i=j -> j=3

int a=2, b=2, c,d,e,f;
t= d=a--, e=d--, f=--e;
printf("t=%d", t) // t=1
// 第一次计算 d = a-1
// 第二次计算 d = a, a-1


a=2*6,a*3,a+5;
// 第一次计算，表达式41。  a=2*6 -> a=12*3 -> a=36+5
// 第二次计算，表达式17。  a=2*6 -> 12*3 ->a=12+5
```



**条件运算符**

| 运算符 | 对象数与位置 | 运算规则                                          | 对象类型 | 结果类型     | 结合性   |
| ------ | ------------ | ------------------------------------------------- | -------- | ------------ | -------- |
| ? :    | 三目中缀     | 对e1?e2:e3<br />e1为真,获得e2<br />e1为假，获得e3 | 表达式   | e2(e3)的类型 | 自右向左 |

条件运算符：C语言唯一的三目运算符
说明：`其他运算符 优先于 条件运算符 优先于 赋值、算术复合赋值运算符 优先于 逗号运算符`

```c
int a=2, b=2, c=2, d=2, t;
t = a==1?(c=1):(d=3);
printf(" t=%d",t); // t=3, d=3
```



### 位运算符和位运算符表达式

**十进制转二进制** - [学习地址](https://zhuanlan.zhihu.com/p/159127499)

方法1：整除法，用2整除十进制数，得到一个商和余数在用2去除商，又会得到商和余数，如此重复，直到商小于1时为止，然后把先得到的余数作为二进制的低位有效位，后得到的余数作为二进制的高位有效位

- 因为是将商除以二，所以不可能出现余数大于等于二的值
- 

![image-20211017212948225](/../assets/images/2021/2021-07-27-code_design/image-20211017212948225.png)

方法2：先将十进制分解为2的不同整数次幂的和，然后将这些数分别转化为二进制数，最后将这些二进制数相加就得到结果。

例如，将十进制数81转换为二进制数。
$$
81=64+16+1=2^6+2^4+2^0\\
=(1000000)_2 + (10000)_2+(1)_2\\
=(1010001)_2
$$

**二进制转换为十进制**  -[学习地址](https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6/393189?fr=aladdin)

方法1：从右向左用二进制的每个数去乘与2的的对应次方并递增
$$
1010001 = 1\times2^0 + 0*2^1 + 0\times2^3 +...\\
=1\times2^0+1\times2^4+1\times2^6\\
=1+16+64\\
=81
$$


 方法2：采用幂乘加法。


$$
11010 = 1\times2^4+1\times2^3+1\times2^1\\
=16+8+2\\
=26
$$


**二进制转换未八进制**

方法：将二进制右向左每三位分为一组，最左端不够三位补零，最后将每小组转换为一位八进制数

例如，将二进制数为`11010`转换为相应的八进制数

分组：`011 010`,转换为八进制数32，表示为32
$$
11010 = 011 \& 010\\
= 3 \& 2\\
=32
$$

**八进制转换为二进制**

方法：从右向左每位八进制数转换为三位二进制，然后去掉最左端的零。

例如，将八进制数为32转换为相应的二进制数

32按位转换`011 011`

$$
32 =3 \ 2\\
=  011 \ 010\\
=32
$$



**十进制转八进制**

方法：

1. 计算是十进制数中存在多少个8，将每个位的数是8及以上的数进一,8直接进1，9则将位置1
2. 将十位的数乘与2，在个位和十位之间分配乘积，逢8进1，在十位及以上都重复步骤二，最终得到八进制数

$$
73 =  9 \times8 + 1 \\
=0121
$$



**二进制转换为十六进制**

方法：将二进制右向左每四位分为一组，最左端不够四位补零，最后将小组转换为一位十六进制数

例如，将二进制数`11010`转换为相应的十六进制数

分组：`0001 1010`, 转换为十六进制数1A，表示为`0x1A`
$$
11010 = 0001 \ 1010\\
= 1 \ 10\\
=1A
$$


**十六进转换为制二进制**

方法：将二进制右向左每四位分为一组，最左端不够四位补零，最后将小组转换为一位十六进制数

例如，将二进制数`11010`转换为相应的十六进制数

分组：`0001 1010`, 转换为十六进制数1A，表示为`0x1A`
$$
1A = 1 \ 10\\
= 0001 \ 1010\\
=0001\ 1010
=11010
$$

**原码 、返码、补码**  [学习地址](https://www.cnblogs.com/wqbin/p/11142873.html)

计算机系统中整数一律采用补码表示（存储），原因在于使用补码，可以将符号位和其他为统一处理；同时，减法也可按加法来处理。另外，两个使用补码表示的数相加，如果最高位（符号位）有进位，则进位被舍弃

计算机中数值的表示

1. 二进制位与字节：字节是内存的基本单位，1字节由8个二进制（bit）组成，每个二进制位为0或1。1字节中各二进制位的编码如下图
   ![image-20211019081545172](/../assets/images/2021/2021-07-27-code_design/image-20211019081545172.png)
   
2. 数值的原码表示：将最高位作为符号位（0表示整数，1表示负数），其余各位代表数值本身的绝对值（以二进制形式表示）的表示形式、

   ```
   -9的原码是10001001
   +9的原码是00001001
   ```

   

3. 数值的反码表示：整数的反码与原码相同，负数的反码的符号位为1，取与各位为该绝对值的原码按位取反。

   ```
   +9的反码是00001001
   -9的反码是11110110
   ```

   

4. 数值的补码表示：整数的补码与原码相同，负数的补码的符号为1，其余各位为该数绝对值的原码按位取反；然后在末位加1。  [学习地址](https://jingyan.baidu.com/article/1e5468f90a9568484861b77c.html)

   ```
   +9的补码是00001001
   -9的原码是10001001--> 除符号位其余各位按位取反11110110--> 末位加1得到-9的补码是11110111
   -8的原码是10001000--> 除符号位其余各位按位取反11110111--> 末位加1得到-8的补码是11111000    
   # -8计算过程因为11110111加1后之前的几位无法无法容纳，所以进位1+1 -> 2+2 -> 4+4 -> 8
   ```

**补码的减法中运用**

1. 得出结果为负数要进行补码逆转

2. 得出结果为正数无需进行补码逆转  （补码的意义就是去除-0这种存在）

$$
\begin{equation*} %加*表示不对公式编号
	\begin{split}
    9-8
    & =9+(-8)\\
    & =[0000\ 1001]_原 \ +[1000\ 1000]_原\\
    & =[0000 1001]_补  \ +[1111\ 1000]_补 \\
    & = [0000\ 0001]_补  \\
    & = 1
	\end{split}
\end{equation*}
$$


$$
\begin{equation*} %加*表示不对公式编号
	\begin{split}
1-13 
& =1+(-13)\\
& =［0000\ 0001］+［1000\ 1101］\\
& =［0000\ 0001］+［1111\ 0011］\\
& = ［1111\ 0100］-1\\
&=［1111\ 0011］\\  
& =［1000\ 1100］\\
&=-12
	\end{split}
\end{equation*}
$$

$$
\begin{equation*} %加*表示不对公式编号
	\begin{split}
-5-2
&=-5+(-2)\\
&=［1000\ 0101］+［1000\ 0010］\\
&=［1111 1011］+［1111 1110］\\
&=［1111 1001］-1\\
&=［1111 1000］=［1000 0111］\\
&=-7
	\end{split}
\end{equation*}
$$


$$
\begin{equation*} %加*表示不对公式编号
	\begin{split}
-5-(-2)
&=-5+(2)\\
&=［1000\ 0101］+［0000\ 0010］\\
&=［1111\ 1011］+ ［0000\ 0010］\\
&=［1111\ 1101］-1 \\
&= ［1111\ 1100］\\
&=［1000\ 0011］\\
&= -3 
	\end{split}
\end{equation*}
$$

**位逻辑运算符**

1. 运算对象只能是整型或字符型。除`按位非`为单目运算符外，其余均为双目运算符。
2. 参与逻辑运算时，运算对象以二进制形式进行相应的按位运算
3. `~` 优先于 `双目算数运算符` 优先与 `关系运算符` 优先于 `&` 优先于 `^` 优先于 `|` 优先于 `双目运算符`
4. `~`与`单目逻辑运算符`、`自增`、`自减`、`单目算数运算符`、`长度运算符的优先级相同`，结合性是从右至左。

| 名称   | 运算符 | 对象数与位置 | 运算规则       | 对象类型 | 结果类型 | 结合性   |
| ------ | ------ | ------------ | -------------- | -------- | -------- | -------- |
| 位非   | ~      | 单目中缀     | \~1为0，\~0为1 | 整型     | 整型     | 自右向左 |
| 位与   | &      | 单目中缀     | 参见下表       | 整型     | 整型     | 自右向左 |
| 位或   | \|     | 双目中缀     | 参见下表       | 整型     | 整型     | 自左向右 |
| 按异或 | ^      | 双目中缀     | 参见下表       | 整型     | 整型     | 自左向右 |

| a    | b    | a&b  | a\|b | a^0  |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |
| 0    | 1    | 0    | 1    | 1    |
| 1    | 0    | 0    | 1    | 1    |
| 1    | 1    | 1    | 1    | 0    |

![image-20211116073951920](/../assets/images/2021/2021-07-27-code_design/image-20211116073951920.png)

![image-20211116074216370](/../assets/images/2021/2021-07-27-code_design/image-20211116074216370.png) 



注意：位逻辑运算符用于数据中的二进制位进行测试、置位。

按位与

1. 按位与的主要作用是提取（或保留）一个数的某些位，其余各位置0.
2. 例如，将二进制数是00010010高四位不变，低四位置0.
3. 方法：`00010010 & 11110000`
4. 结果：`00010000`



按位或

1. 按位或的主要作用是将一个数的某（些）位置1，其余各位不变。
2. 例如，将二进制数是00010010高四位不变，低四位置1。
3. 方法：`00010010 | 00001111`
4. 结果：`00011111`

按位异或

1. 按位异或的主要作用是使一个数的某些位反转（既原来为1的变为0，为0的变为1），其余各位不变
2. 例如，将二进制数是00010010高四位不变，第四位反转
3. 方法：`00010010 ^ 00001111` 
4. 结果:`00011101`

按位非

- 按位非的主要作用是间接地构造一个函数，以增强程序的可移植性。





### 位移位运算符

| 名称 | 运算符 | 对象数与位置 | 运算规则         | 对象类型 | 结果类型 | 结合性   |
| ---- | ------ | ------------ | ---------------- | -------- | -------- | -------- |
| 左移 | <<     | 双目中缀     | a<<b, a向左移b位 | 整型     | 整型     | 自左向右 |
| 右移 | >>     | 双目中缀     | a>>b, a向右移b位 | 整型     | 整型     | 自左向右 |

![image-20220719073125529](/../assets/images/2021/2021-07-27-code_design/image-20220719073125529.png)

**示例：**

```c
#include <stdio.h>
/*
注意： 有符号数向右移的时候补的是符号位   符号位：0为正，1为负
注意： 无符号数向右移的时候补的是0
注意： 运算过程先转换成补码在进行运算  （二次验证）
*/
void main(){
	int a=10,b=-1,c=0;    
    printf("a: %d", a<<1);     // 20   
    printf("b: %d", b<<2);     // -4  解释：符号位不参与位移运算
    printf("c: %d", c<<3);     // 4   解释：零不管怎么移动都是0，零的二进制位全部都是零
    printf("c: %d", b<<32);    // -1    解释：符号位不参与位移运算，移出位超出容纳数量，直接从头重新移动
    printf("d: %d", d>>1);     // -1   解释：-1的补码时 11111 1111， 右移补1个符号位的情况下，还是11111 1111
    
    unsigned short a=0111;
	printf("%o\n", a<<3);   // 1110
	printf("%o\n", a>>4);   // 4
    
	short b=-4;
	printf("%d\n", b<<3);   // -32
	printf("%d\n", b>>4);   // -1
    
}
/*
二进制位前八位： 128,64,32,16,8,4,2,1
向左位移前a的二进制位: 0001010    2+8=10
向左位移后a的二进制位: 0010100    16+4=20
*/

```



**示例：**

从键盘输入一个正整数保存至int型变量num，输出由8~11位构成的数（从低位、0号开始编号）。

```c
/* 
思路：
1.从键盘获取一个数字，并将这个数字进行位右移8位，赋值给num
2.构造一个数字，低四位全是1，高位全是0，赋值个mark
3.将mark和num进行与运算，然后输出
*/

#include <stdio.h>
void main(){
	int num, mark; 
	scanf("%d", &num);  // 从键盘获取一个数字
	num=num>>8;         // 将这个数字进行有移四位，若是数字小于等于256则最终结果为0，因为2的8次放是256
	mark=~(~0<<4);     //  ~0获取一个全为1的数； 左移4次得到低四位是0的数； 再次取反低四位变为1.高位全变成0
	printf("result=%d \n", num&mark);    //输出一个数
}
// 输入257，输出1
// 输入513，输出2

```







### **长度运算符**

长度运算符是单目运算符，长度运算符的使用形式sizeof(数据类型符) 或 sizeof(变量)

说明：

1. 用来计算数据类型或者变量在内存占用的多少个字节
2. 与单目算术运算符（+, -）、 单目逻辑运算符（~） 、自增和自减运算符（++、--）的优先级相同。
3. 上述优先级相同的运算符的结合性都是从右至左。

```c
#include <stdio.h>
void main(){
    int i; short s; unsigned long t; float f; char c;
    printf("%d", sizeof(i));  // 4
    printf("%d",sizeof(s));   // 2
    printf("%d",sizeof(t));   // 4
    printf("%d",sizeof(f));   // 4
    printf("%d",sizeof(c));   // 1
    printf("%d",sizeof(long));   // 4
    printf("%d",sizeof(unsigned int));   // 4
    printf("%d",sizeof(unsigned short));   // 2
}
```





### 数据类型转换



**自动类型转换**

参与运算的各个数据都转换成数据长度较长的数据类型，然后计算，结果类型就是数据长度较长的数据类。即“就高不就低” 或 “就长不就短”的原则。

- **横向向左的箭头**，表示**必须**的转换。char型或short型必须转换城int型，float型必须转换成double型； 

- **纵向向上的箭头**，表示不同类型一起运算的时候转换方式。

```c
#include <stdio.h>
void main(){
    // 就长不就短原则
   float f, f1=1.0,f2=2.0; double d;
    printf("%d",sizeof(d));   // 8
    printf("%d",sizeof(f1+d));   // 8
    printf("%d",sizeof(f1+f2));   // 4
}

```



![image-20220817190802498](/../assets/images/2021/2021-07-27-code_design/image-20220817190802498.png)





示例：

![image-20220817191532325](/../assets/images/2021/2021-07-27-code_design/image-20220817191532325.png)









**赋值类型转换**

赋值类型转换：先将运算结果的数据类型自动转换为左边的变量的数据类型，然后在赋予该变量。本质商是“**就左不就右**”的转换规则。

```c
#include <stdio.h>
void main(){
  int a=1; float b=2.1; char c='a'; 
  a=b+c;
  printf("%d", a) ;
}
/*
1.先将变量c的char类型转换成float类型， 然后与变量b相加
2.将步骤一相加的结果转换成int型，然后赋值给变量a
*/
```



**强制类型转换**

强制类型转换：强制改变表达式计算结果的数据类型。

语法格式：(数据类型符)(表达式)

例如：

```c
#include <stdio.h>
void main(){
    char a, x, y;
    printf("%d ", sizeof((double)a));  // 8
    printf("%d ", sizeof((int)(x+y))); // 4
    printf("%.2f ", (float)5/2);       // 2.50    先将5转换成float类型在运算
    printf("%.2f ", (float)(5/2));     // 2.00    强制转换运算结果
}
```





### C语言运算符优先级

转自 [C语言运算符优先级和结合性一览表 (biancheng.net)](http://c.biancheng.net/view/161.html)

| 优先级 | 运算符 | 名称或含义       | 使用形式                     | 结合方向 | 说明       |
| ------ | ------ | ---------------- | ---------------------------- | -------- | ---------- |
| 1      | []     | 数组下标         | 数组名[常量表达式]           | 左到右   |            |
|        | ()     | 圆括号           | (表达式)<br />函数名(形参表) |          |            |
|        | .      | 成员选择（对象） | 对象.成员名                  |          |            |
|        | ->     | 成员选择（指针） | 对象指针->成员名             |          |            |
| 2      | -      | 负号运算符       | -表达式                      | 右到左   | 单目运算符 |
|        | (类型) | 强制类型转换     | (数据类型)表达式             |          |            |
|        | ++     | 自增运算符       | ++变量名<br />变量名++       |          | 单目运算符 |
|        | --     | 自减运算符       | --变量名<br />变量名--               |          | 单目运算符 |
|        | *      | 取值运算符       | *指针变量                    |          | 单目运算符 |
|        | &      | 取地址运算符     | &变量名                      |          | 单目运算符 |
|        | !      | 逻辑非运算符     | !表达式                      |          | 单目运算符 |
|        | ~      | 按位取反运算符   | ~表达式                      |          | 单目运算符 |
|        | sizeof | 长度运算符       | sizeof(表达式)               |          |            |
| 3      | /      | 除               | 表达式  / 表达式             | 左到右   | 双目运算符 |
|        | *      | 乘               | 表达式*表达式                |          | 双目运算符 |
|        | %      | 余数（取模）     | 整型表达式%整型表达式        |          | 双目运算符 |
| 4      | +      | 加               | 表达式+表达式                | 左到右   | 双目运算符 |
|        | -      | 减               | 表达式-表达式                |          | 双目运算符 |
| 5      | <<     | 左移             | 变量<<表达式                 | 左到右   | 双目运算符 |
|        | >>     | 右移             | 变量>>表达式                 |          | 双目运算符 |
| 6      | >      | 大于             | 表达式>表达式                | 左到右   | 双目运算符 |
|        | >=     | 大于等于         | 表达式>=表达式               |          | 双目运算符 |
|        | <      | 小于             | 表达式<表达式                |          | 双目运算符 |
|        | <=     | 小于等于         | 表达式<=表达式               |          | 双目运算符 |
| 7      | ==     | 等于             | 表达式==表达式               | 左到右   | 双目运算符 |
|        | !=     | 不等于           | 表达式!=  表达式             |          | 双目运算符 |
| 8      | &      | 按位与           | 表达式&表达式                | 左到右   | 双目运算符 |
| 9      | ^      | 按位异或         | 表达式^表达式                | 左到右   | 双目运算符 |
| 10     | \|     | 按位或           | 表达式\|表达式               | 左到右   | 双目运算符 |
| 11     | &&     | 逻辑与           | 表达式&&表达式               | 左到右   | 双目运算符 |
| 12     | \|\|   | 逻辑或           | 表达式\|\|表达式             | 左到右   | 双目运算符 |
| 13     | ?:     | 条件运算符       | 表达式1?  表达式2: 表达式3   | 右到左   | 三目运算符 |
| 14     | =      | 赋值运算符       | 变量=表达式                  | 右到左   |            |
|        | /=     | 除后赋值         | 变量/=表达式                 |          |            |
|        | *=     | 乘后赋值         | 变量*=表达式                 |          |            |
|        | %=     | 取模后赋值       | 变量%=表达式                 |          |            |
|        | +=     | 加后赋值         | 变量+=表达式                 |          |            |
|        | -=     | 减后赋值         | 变量-=表达式                 |          |            |
|        | <<=    | 左移后赋值       | 变量<<=表达式                |          |            |
|        | >>=    | 右移后赋值       | 变量>>=表达式                |          |            |
|        | &=     | 按位与后赋值     | 变量&=表达式                 |          |            |
|        | ^=     | 按位异或后赋值   | 变量^=表达式                 |          |            |
|        | \|=    | 按位或后赋值     | 变量\|=表达式                |          |            |
| 15     | ,      | 逗号运算符       | 表达式,表达式,…              | 左到右   |            |



**易错优先级问题**

| 优先级问题                                    | 表达式               | 经常误认为的结果                                        | 实际结果                                                     |
| --------------------------------------------- | -------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| . 的优先级高于 *（-> 操作符用于消除这个问题） | *p.f                 | p 所指对象的字段 f，等价于： (*p).f                     | 对 p 取 f 偏移，作为指针，然后进行解除引用操作，等价于： *(p.f) |
| [] 高于 *                                     | int *ap[]            | ap 是个指向 int 数组的指针，等价于： int (*ap)[]        | ap 是个元素为 int 指针的数组，等价于： int *(ap [])          |
| 函数 () 高于 *                                | int *fp()            | fp 是个函数指针，所指函数返回 int，等价于： int (*fp)() | fp 是个函数，返回 int*，等价于： int* ( fp() )               |
| == 和 != 高于位操作                           | (val & mask != 0)    | (val &mask) != 0                                        | val & (mask != 0)                                            |
| == 和 != 高于赋值符                           | c = getchar() != EOF | (c = getchar()) != EOF                                  | c = (getchar() != EOF)                                       |
| 算术运算符高于位移 运算符                     | msb << 4 + lsb       | (msb << 4) + lsb                                        | msb << (4 + lsb)                                             |
| 逗号运算符在所有运 算符中优先级最低           | i = 1, 2             | i = (1,2)                                               | (i = 1), 2                                                   |

- `*(p.f)`

**逻辑运算符注意**

- `0为假，非0为真；非0包括负数`  
- `逻辑运算符的优先级是2， 单目运算符的优先级都是2`







## **结构化程序设计**

**结构化程序设计**

1. 输入/输出函数的使用方法
2. 选择结构及其程序设计
3. 循环结构及其程序设计



**难点：**

1. 格式输入/输出函数中的格式说明符的使用
2. 多分支结构程序设计
3. 二重循环程序设计





### **结构化程序设计方法**

**结构化程序设计**：是以模块功能和处理过程设计为主的详细设计的基本原则。

1. 自顶向下，逐步求精。
2. 模块化设计：遵循模块独立性原则，每个模块的功能独立而且明确。C语言中，一个模块对应函数
3. 结构化编码：任何程序都由顺序、选择、循环三种基本结构组成，清晰地表示程序的逻辑结构



**顺序结构**

顺序结构是程序的一个基本结构，它是按照书写顺序依次执行操作。

![image-20220818090343357](/../assets/images/2021/2021-07-27-code_design/image-20220818090343357.png)



**选择结构**

选择结构又称分支结构，是根据某个或某些条件，从若干个操作中选择某个操作执行的一种控制结构。

选择结构分为单分支选择结构、双分支选择结构和多分支选择结构三种。

![image-20220818090619046](/../assets/images/2021/2021-07-27-code_design/image-20220818090619046.png)

![image-20220818100949987](/../assets/images/2021/2021-07-27-code_design/image-20220818100949987.png)



**循环结构**

循环结构是由循环控制条件控制循环体是否重复执行的一种控制结构

循环结构分为当型循环结构、直到型循环结构和次数型循环结构三种。

![image-20220818102508941](/../assets/images/2021/2021-07-27-code_design/image-20220818102508941.png)



![image-20220818101933403](/../assets/images/2021/2021-07-27-code_design/image-20220818101933403.png)



 

### 顺序结构

顺序结构的程序包括以下几部分：

1. 程序开头的编译预处理命令
2. 变量类型的说明
3. 提供数据的语句
4. 运算部分
5. 输出部分

本节介绍几种顺序执行的语句：赋值语句、函数调用语句、表达式语句、复合语句



**赋值语句**

【格式1】 变量名 赋值运算符 表达式；   `a = 1+1;`

【格式2】 变量名 复合赋值运算符 表达式；   `a += 1;`

【示例】a=2; s=a+1; s+=2;



**函数调用语句**

1. 调用系统函数：必须在程序清单的开头写上下列命令： `#include <头文件名.h>`
2. 函数调用语句的格式和功能：
   - 【格式】`函数名(参数1, 参数2, ....);`
   - 【示例】编程序，调用系统函数计算9的平方根、-10的绝对值、sin(3)的值。

```c
#include <stdio.h>
#include <math.h>
void main(){
    float sqrt1, fabs1, sin1;
	sqrt1 = sqrt(9.0);
   	fabs1 = fabs(9.0);
    sin1 = sin(9.0);
    printf("%.2f, %.2f, %.2f ",  sqrt1, fabs1, sin1 );     // 3.00, 9.00, 0.41
}
```



**表达式语句**

【格式】表达式；    `1+1;`

【功能】计算表达式的值。

注意：任何表达式都能构成语句。



**复合语句**

【格式】 `{语句1;  语句2; ... 语句n;}`

【功能】依次执行语句1、语句2、.....、语句n。

【说明】

1. 复合语句虽然含有多条语句，但是整体上英看成一条语句.
2. 复合语句中的语句若有数据定义语句，要放在复合语句中其他语句的前面。

```c
#include <math.h>
#include <stdio.h>
#define PI 3.14   # π
#define R 10.0    #半径
void main(){
	float a, b, c, d;
	{
	a=2.0*PI*R;                                   //圆的周长公式：C=2πr
	b=PI*R*R;                                     //圆的面积公式：S=πr²
	c=4*PI*R*R;                                   //球的表面积公式：S=4πR²
	d=4.0/3.0*PI*R*R*R;                           //球的计算公式：V=（4/3）πR³：
	printf("%.2f %.2f %.2f %.2f ", a, b, c, d);   
	
	}
	
}
```



### 字符输入/输出函数

**字符输出函数**

【格式】 `putchar(ch)`

【参数】"ch"可以是一个字符型变量，字符型常量、整型变量或整型常量，也可以是一个转义字符或整型表达式，但不能是字符串。

【功能】将参数ch对应的字符输出到显示器上。

【说明】

1. `putcharr(ch`函数只能用于单个字符的输出，依次输出一个字符。
2. 若程序中用到`putchar(ch)` ，则在程序的开头加上`#include <stdio.h>`

```c
#include <stdio.h>
void main(){
	char a='b';
	putchar(65);    // A
	putchar(a);     // b
	putchar('\n');     
	putchar('b');   // b
	putchar('b'+1); // c
	putchar(65+1);  // B
}
```



**字符输入函数**

【格式】`getchar()`

【参数】无参数

【功能】从键盘输入一个字符。

【说明】

1. `getchar()`函数只能用于单个字符的输入， 一次输入一个字符。输入的数字也是按字符处理。当输入多于一个字符时，只能接收一个字符。
2. `getchar()`函数输入的字符可以赋给i而一个字符变量或整型变量，也可以作为表达式的一部分。
3. 程序中用到`getchar(ch)`, 要在程序的开头加`#include <stdio.h>`

```c
// 编程序输入单个字符， 判断是否数字字符，是则输出字符Y，否则输出字符N
#include <stdio.h>
void main(){
	char ch, tag;
	ch=getchar();
	tag=('0'<=ch&&ch<='9')? 'Y':'N';
	putchar(tag);
}
```





### **格式输入/输出函数**

**格式输出函数prinf()**

【格式】 `prinf(格式控制字符串，输出项表)`

【参数】”格式控制字符串“是由控制输出格式的字符组成的字符串。”输出项表“是用逗号分隔的若干个表达式。

【功能】按照用户指定的格式把指定的数据输出到显示器

【说明】

1. ”格式控制字符串“作用是将 输出项表中的数据从内存的二进制形式转换成指定的格式输出。格式控制字符串由格式是说明符、附加格式说明字符、转义字符和普通字符组成。
2. `printf()`中格式说明符与输出项一一对应，若格式说明符的个数少于输出项的个数时，则多余的输出项不输出，若格式说明符的个数多于输出项的个数时，则对缺少的项输出不确定值。
3. 格式字符**x、e、g**可以用小写字母，也可以用大写字母。若使用大写字母，则输出数据包含的字母大写。除格式字符x、e、g外，其他格式字符必须采用小写字母。例如`"%f"` 不能写成`”%F“`

```c
#include <stdio.h>
void main(){
	int num=583;
	printf("num=%d, num1=%5d;", num, 123);
}
```

函数常用的格式字符及其含义：

| 格式字符 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| d        | 以十进制有符号形式输出整型数据（正整型不输出符号+）          |
| o        | 以八进制无符号形式输出整型数据（不输出前缀0）                |
| X、x     | 以十六进制无符号形式输出整型数据（不输出前缀0x）<br />以x则输出小写十六进制数符a~f<br />以X则输出大写十六进制数符A~F |
| u        | 以十进制无符号形式输出整型数据                               |
| f        | 以小数形式输出实型数据（包括单精度实型和双精度实型）小数部分为6位 |
| G、g     | 以f或e格式中宽度较短的一种格式输出实型数据，不输出无意义的0；<br />在用G时，若以指数形式输出，则指数以大写E表示 |
| c        | 以字符形式输出，只输出一个字符                               |
| s        | 输出字符串                                                   |
|          |                                                              |

```c
#include <stdio.h>
void main(){
	int num=256;
	float f1=0.1;
	char c1='A';
	printf("d=%d, o=%o, X=%X, x=%x, u=%u \n", num, num, num, num, num);  // d=256, o=400, X=100, x=100, u=256
	printf("f=%f, G=%G, g=%g\n", f1, f1, f1);  // f=0.100000, G=0.1, g=0.1
	printf("c=%c, s=%s\n", c1, "BC"); // c=A, s=BC
}
```



附加格式说明字符：

| 附加格式说明字符 | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| l                | 在格式字符d、o、x、u之前,输出长整型数据，<br />在格式字符e、f、g之前，输出双精度实型数据 |
| h                | 输出短整型数据，可用在格式字符d、o、x、u之前                 |
|                  | m表示输出数据所占的域宽。<br />当输出数据宽度小于m且m为正时，输出数据或字符右对齐，左边补空格；当m为负时，输出的数据或字符左对齐，右边补空格。<br />当输出数据宽度大于m时，按实际宽度输出 |
| n(正整数）       | 当输出实型数据时，表示输出n位小数；<br />当输出字符串时，表示截取前n个字符输出 |
| -                | 输出的数据或字符在域内左对齐                                 |
| +                | 指定在有符号数的正整数前面显示正号                           |
| 0                | 输出数值时指定左侧的空位自动置0                              |
| #                | 在八进制和十六进制数前显示前缀0和0x                          |

```c
#include <stdio.h>
void main(){
	long num=256;
	double f1=0.123;
	short sh1=123;
	char c1='A';
	char* s1="test";
	printf("ld=%ld, lo=%lo, lX=%lX, lx=%lx, lu=%lu \n", num, num, num, num, num);  
	printf("lf=%lf, lG=%lG, lg=%lg\n", f1, f1, f1);  
	printf("hd=%hd, ho=%ho, hX=%hX, hx=%hx, hu=%hu \n", sh1, sh1, sh1, sh1, sh1);  
	printf("ms=%5s, -ms=%-7s, nlf=%.2lf, ns=%.2s \n", s1, s1, f1, s1); 
	printf("+d=%+d, 0-m=%0-4d, #o=%#o, #x=%#x\n", num, num, num, num);  
}
/*
ld=256, lo=400, lX=100, lx=100, lu=256
lf=0.123000, lG=0.123, lg=0.123
hd=123, ho=173, hX=7B, hx=7b, hu=123
ms= test, -ms=test   , nlf=0.12, ns=te
+d=+256, 0-m=256 , #o=0400, #x=0x100

*/
```





常用的输出格式

| 数据格式         | 输出格式 |
| ---------------- | -------- |
| 有符号整型数据   | %d       |
| 有符号长整型数据 | %ld      |
| 实型数据         | %m.nf    |
| 字符串数据       | %s       |
| 无符号整型数据   | %u       |
| 无符号长整型数据 | %lu      |
| 字符型数据       | %c       |

