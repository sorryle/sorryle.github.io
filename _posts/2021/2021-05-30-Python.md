---
layout: post
title: Python语言程序设计
category: 计算机语言程序设计
tags: [Python]
excerpt: Python语言程序设计学习笔记
typora-root-url: ..\..
---



## 基本算法

### 恺撒密码

> 是古罗马恺撒大帝用来对军事情报进行加解密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为字母表序列中该字符后面的第三个字符，即，字母表的对应关系如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
>
> 原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
>
> 密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
>
> 对于原文字符P，其密文字符C满足如下条件：C=(P+3) mod 26‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
>
> 上述是凯撒密码的加密方法，解密方法反之，即：P=(C-3) mod 26‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
>
> 假设用户可能使用的输入包含大小写字母a~zA~Z、空格和特殊符号，请编写一个程序，对输入字符串进行恺撒密码加密，直接输出结果，其中空格不用进行加密处理。使用input()获得输入。

```python
tmp = input()
buff = ""
for i in tmp:
    if "a" <= i <= "z" :
        buff += chr(ord("a") + (ord(i)-ord("a") + 3) % 26)
    elif "A" <= i <= "Z" :
        buff += chr(ord("A") + (ord(i)-ord("A") + 3) % 26)
    else:
        buff += i
print(buff)
```

### 梅森旋转算法

待补充



### 科赫曲线的绘制

```python
import turtle
def koch(size, n):
    if n == 0:
        turtle.fd(size)
    else:
        for angle in [0, 60, -120, 60]:
            turtle.left(angle)
            koch(size/3, n-1)

def main():
    level = 3
    koch(400, level)
    turtle.right(120)
    koch(400, level)
    turtle.right(120)
    koch(400, level)
    turtle.hideturtle()
    turtle.done()
main()
```

### 深度优先遍历(DFS)

> 实现一个方法，将JSON对象中所有为空字符串的字段去掉

```python
def bianli(dict_value, tmp_return):
    for i in dict_value:
        dict_value[i]
        if dict_value[i] == '':  # 盘点值是否为空，是则不添加这个值
            pass
        else:
            try:
                dict_value[i].keys()
            except:
                tmp_return[i] = dict_value[i]
            else:  # 判断值是否为字典，是则遍历字典
                tmp_return[i] = {}
                bianli(dict_value[i], tmp_return[i])
    return tmp_return
oj = {'a': 1, 'tmp1': '', 'b': {"c": {'tmp2': '', 'd': 'stromg'}, 'tmp3': '', 'e': {}}}
print(bianli(oj, {})) # {'a': 1, 'b': {'c': {'d': 'stromg'}, 'e': {}}}
```





## 基本语法

`import` 

- `import 库名` 
  - 调用函数： `库名.函数名(函数参数)`
- `from 库名 import 函数`：导入某个函数
  - `from 库名 import *` :导入所有函数
  - 调用函数: `函数名(函数参数)`
- `import 库名 as 别名`
  - 调用函数：`库别名.函数名(函数参数)`

`return`

```python
def a():
    return 1, 2, 3
tmp = a()
print(tmp)  # (1, 2, 3)
print(type(tmp))   <class 'tuple'>
```


`if`

- 二分之结构
  - `<表达式1> if <条件> else <表达式2>`

```python
if '28F'[-1] in ['F', 'f']:
    print('{}里面包含了字母F或者字母f'.format('28F'))  # 28F里面包含了字母F或者字母f


if "a" <= "b" <= "z":
    print('{}大于等于a并且小于等于z'.format('b'))  # b大于等于a并且小于等于z

# 二分之结构
tmp = 1
print("猜{}了".format("对" if tmp==1 else "错"))  # 猜对了
```



**赋值**

```python
tmp = 1 if 1 == 2 else 2
print(tmp)  # 2

a, b = 1, 2
print(a, b)  # 1 2
```

**异常处理**

```python
try: # 可能发生异常的代码
    eval("abc")  
except NameError:  # 只捕捉特定类型的异常，非本类型异常则报错
    print("应该给一个数字类型的字符串")  # 应该给一个数字类型的字符串



try:
    <语句块1>  # 可能发生异常的代码
except:  # 捕捉全部异常
    <语句块2>  # 执行发生异常后执行
else:
    <语句块3>  # 程序没有发生异常情况下执行
finally:
    <语句块4>  # finally的语句一定会执行
```

**循环**

```python
i = 10
while i>0:
    i -= 1
else:
   	print("正常结束")  
# 输出正常结束，因为没有遇到break语句，如果循环有else的情况，没有遇到break语句就会执行行else的语句块

i = 10
while i>0:
    i -= 1
    if i == 5:
        print("不正常退出")
        break
else:
   	print("正常结束")
# 不正常退出
    
    
for i in "test":
    print(i, end="")
else:
    print("正常结束")
# test正常结束
    
for i in "test":
    if "s" == i:
        break
        print("不正常正常结束")
    print(i, end="")
else:
    print("正常结束")
# te
```


**变量**

- 局部变量是函数内定义的变量，全局变量是函数外定义的变量
- 局部变量在函数销毁时同时销毁
- 局部变量和全局变量重名时，使用的就是局部变量
- 局部变量为组合数据类型且未创建，等同于全局变量
- 使用`global`关键字可以在函数内调用全局变量

```python
'''局部变量为组合数据类型且未创建，等同于全局变量'''
ls = ['f', 'F']
def func():
    ls.append(1)
func()
print(ls) #  ['f', 'F', 1]

'''局部变量和全局变量重名时，使用的就是局部变量'''
sa = 1
def func():
    sa = 2
func()
print(sa) #  1

'''使用`global`关键字可以在函数内调用全局变量'''
a = 'test'
def func():
    global a
    print(a)
func()
```



`lambda`

- 匿名函数，用于可在一行内表达的简单函数
- `函数名 = lambda 参数1, 参数2:表达式`

```python
func = lambda a, b: a+b
print(func(1, 2))  # 3 
```



## 语法糖

`;`

- 特殊情况非要把代码写在一行的时候使用`;`来分隔

```python
tmp = 1;print(tmp)
```



`	\`

- 代码写在一行的时候太长的时候可以使用`\`进行换行，换行后和写在一行的效果是一致的

```python
print \
(1)  # 1
```



**二元操作符**

```python
t = 1

t += 1
print(t)  # 2

t -= 1
print(t)  # 1

t *= 3
print(t)  # 3

t /= 4
print(t)  # 0.75

t **= 5
print(t)  # 0.2373046875

t %= 7
print(t)  # 0.2373046875

t //= 2
print(t)  # 0.0
```

**切片**

- <font color='red'>左闭右开</font>

```python
tmp = "一二三四五六七八九十"
print(tmp[4])  # 五
print(tmp[3:])  # 四五六七八九十
print(tmp[:3])  # 一二三
print(tmp[:-3])  # 一二三四五六七
print(tmp[-3:])  # 八九十
print(tmp[2:3])  # 三
print(tmp[::2])  # 一三五七九
print(tmp[::-1])  # 十九八七六五四三二一
```





## 基础函数

`eval` - [学习地址](https://www.runoob.com/python/python-func-eval.html)

- 函数用来执行一个字符串表达式，并返回表达式的值。
- 表达式就是字符串类型的Python语句，`eval`函数会把字符串类型的Python语句变成Python语句

```python
eval("print('Hello World')") # Hello World
```



`print`

- 接收值，然后打印到控制台

```python
print('Hello World') # Hello World

# 打印结尾以逗号结尾
for i in ['1', '2', '3', '4']:
    print(i, end=",") # 1,2,3,4,
    
    
# 加入空格输出
print("Hello", "World") # Hello World
```



`range`

- `range(N)` 产生0到N-1的整数序列，共N个
- `range(M,N)`产生M到N-1的整数序列，共N-M个
- `range(N,M,S)`产生N开头，到M-1结尾，步长为S的列表

```python
for i in range(10):
    print(i, " ", end="")  # 0  1  2  3  4  5  6  7  8  9  
print()
for i in range(5, 10):
    print(i, " ", end="")  # 5  6  7  8  9  
for i in range(1, 6,2):
    print(i, ",", end="")  # 1 ,3 ,5 ,
```



`map(function, iterable, ...)`

> 第一个参数function以参数序列中的每一个元素调用function函数，返回包含每次function函数返回值的新列表

- function – 函数
- iterable - 一个或多个序列

```python
tmp = ['1', '2', '3', '4']
print(sum(map(eval, tmp)))  # 10
```



### 数值类

`hex(x)`

- 整数x的小写字符串的十六进制形式

`oct(x)`

- 整数x的小写字符串的八进制形式

`max(x1, x2, ..., xn)`

- 求最大值，n不限

```python
print(max([1, 2, 3, 4, 5]))  # 5

print(max(1, 2, 3, 4, 5))  # 5
```



`min(x1, x2, ..., xn)`

- 求最小值，n不限

```python
print(max([1, 2, 3, 4, 5]))  # 1

print(max(1, 2, 3, 4, 5))  # 1
```



`abs`

- 求绝对值
- 参数1是需要求绝对值的数

```python
print(abs(-1021))  # 1021
```



`divmod(x,y)`

- 商余，`(x//y, x%y)`同时输出商和余数

```python
tmp = divmod(2, 2)
print(tmp)  # (1, 0)
print(type(tmp))  # <class 'tuple'>
```



`round`

- `round(x, d)`：对`x`四舍五入，`d`是小数截取位数
- 浮点数间运算及比较用round()函数辅助
- 不确定位数一般发生到$10^{-16}$作用，`round()`十分有效

```python
print(0.1+0.2 == 0.3) # False
print(round(0.1+0.2, 2) == 0.3) # True
```



`Pow`

- 可正可负，没有取值范围
- `pow(x, y[,z])`函数：计算$x^y$,想算多大算多大

```python
# 求2的8次方是多大
print(pow(2, 8)) # 256

# 求2的8次方的结果除2余数是多少
print(pow(2, 8, 2))  #  0
```



### 字符串



`encode('utf-8')`

- 以`utf-8`编码数据

`decode('utf-8')`

- 以`utf-8`解码数据

```python
st = '二狗子'.encode("utf-8")
print(st)
print(st.decode('utf-8'))
```





`strip()`

- 去除两边指定字符,接收一个字符串，会去除两旁参数字符串中包含的字符，不指定字符串默认去除空白

```python
# 去除空白
s = "    1    "
print(s.strip())  # 1

# 去除指定字符串
s = "222---1---222"
print(s.strip("-2"))  # 1
```



`chr(u)`

- u为Unicode编码，返回其对应的字符

```python
tmp = chr(98)
print(tmp)  # b
print(type(tmp))  # <class 'str'>
```

`ord(x)`

- x为字符，返回其对应的Unicode编码

```python
tmp = ord("陈")
print(tmp)  # 38472
print(type(tmp))  # <class 'int'>
```

`lower()`

- 把字符串转换为小写

```python
print('CBD'.lower())  # cbd
```

`upper()`

- 把字符串大写

```python
print('CBD'.upper())  # ABC
```

`split(sep=None)`

- 由`str`根据`sep`被分隔的部分组成

```python
tmp = "A,B,C,D,E".split(",")
print(tmp)  # ['A', 'B', 'C', 'D', 'E'] 
print(type(tmp))  # <class 'list'>
```

`count(sub)`

- 返回字串`sub`在`str`中出现的次数

```python
tmp = '我是你爸爸的爸爸，也就是爷爷'.count("爸爸")
print(tmp)  # 2
print(type(tmp))  # <class 'int'>
```

`replace(old, new)`

- 返回字符串`str`副本，所有`old`子串被替换为`new`

```python
tmp = '我是你爸爸的爸爸，也就是爷爷'.replace("爸爸", "老子")
print(tmp)  # 我是你老子的老子，也就是爷爷
print(type(tmp))  # <class 'str'>
```

`center(width, [,fillchar])`

- 字串符`str`根据`width`居中，`fillchar`可选

```python
print('test'.center(20, '='))
# ========test========
```



`join(iter)`

- 在`iter`变量除最后元素外每个元素后增加一个`str`

```python
print(",".join('test'))  # t,e,s,t
```



`format` - [学习地址](https://www.runoob.com/python/att-string-format.html)

- 格式化字符串的函数 `str.format()`，它增强了字符串格式化的功能

- 基本语法是通过`{}`和`:`来代替以前的`%`。

- `format`函数可以接收不限个参数，位置可以不按顺序

- 槽内部对格式化的配置方式

  - | ：       | <填充>             | <宽度>                 | <对齐>                              | <,>                      | <.精度>                                        | <类型>                                                       |
    | -------- | ------------------ | ---------------------- | ----------------------------------- | ------------------------ | ---------------------------------------------- | ------------------------------------------------------------ |
    | 引导符号 | 用于填充的单个字串 | 槽设定的<br />输出宽度 | <左对齐<br />>右对齐<br />^居中对其 | 数字的<br />千分位分隔符 | 浮点数小数<br />精度或字符串<br />最大输出长度 | 整数类型<br />b，c，d，o，x，X<br />浮点数类类型<br />e，E，f，% |

    

```python
print("{} {}".format{"hello", "world"} # 不指定位置，按默认顺序)
# hello world

print("{0} {1}".format("hello", "world") # 设置置顶位置)
# hello world

print("{1} {0} {1}".format("hello", "world") # 设置指定位置)
# world hello world

print("名称：{name}，年龄: {age}".format(name='张三', age=18))
# 名称：张三，年龄：18

site = {"name":"张三", "age": "18"}
print("名称：{name}，年龄：{age}".format(**site))
# 名称：张三，年龄：18
      
my_list = ['张三', '18']
print("姓名：{0[0]}, 年龄:{0[1]}".format(my_list))
# 姓名：张三，年龄：18

print("姓名：{}，余额：{:.3f}".format('陈新世', 3.14159)) # 保留三位小数，并且四舍五入
# 姓名：陈新世，余额：3.141
      
print("{:*^5}前面是槽".format(2))  # **2**前面是槽
      
print("{:,.3f}前面是槽".format(25631325156.65165156))  # 25,631,325,156.652前面是槽
      
print("{0:b}，{0:c}，{0:d}，{0:o}，{0:X}".format(100))  # 1100100
      

```

### 时间

`time`

- 获取当前系统时间戳，浮点数

```python
import time
tmp = time.time()
print(tmp)  # 1620555274.9285612
print(type(tmp))  # <class 'float'>
```

`ctime(sec)`

- 格式化时间戳为可读时间形式字符串。`sec`未传入则以本地时间为准

```python
import time
tmp = time.ctime()
print(tmp)  # Sun May  9 18:15:08 2021
print(type(tmp))  # <class 'str'>
```

`gmtime`

- 获取一个时间对象

```python
import time
tmp = time.gmtime()
print(tmp)  # time.struct_time(tm_year=2021, tm_mon=5, tm_mday=9, tm_hour=10, tm_min=17, tm_sec=17, tm_wday=6, tm_yday=129, tm_isdst=0)
print(type(tmp))  # <class 'time.struct_time'>
```

`localtime(sec)`

- 格式化时间戳为时间对象。`sec`未传入则以本地时间为准

```python
import time
ti = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1621691486.8812747))
print(ti) # 2021-05-22 21:51:26
print(type(ti)) # <class 'str'>
```



`perf_counter`

- 返回一个CPU级别的精确时间计数值，单位为秒
- 由于这个计数值起点不确定，连续调用差值才有意义

```python
import time
start = time.perf_counter()
print("1")  # 1
end = time.perf_counter()
print("程序打印用时{:.10f}".format(start - end))  # 程序打印用时-0.0000040000
```



**时间格式**

| 格式化字符串 | 日期/时间说明 | 值范围和实例                   |
| :----------: | ------------- | ------------------------------ |
|      %Y      | 年份          | 0000~9999,例如：1900           |
|      %m      | 月份          | 01~12，例如：10                |
|      %B      | 月份名称      | January-Decmber，例如：April   |
|      %b      | 月份名称缩写  | Jan-Dec，例如：Apr             |
|      %d      | 日期          | 01~31，例如：25                |
|      %A      | 星期          | Monday~Sunday，例如：Wednesday |
|      %a      | 星期缩写      | Mon~Sun，例如：Wed             |
|      %H      | 小时(24h制)   | 00~23，例如：12                |
|      %I      | 小时(12h制)   | 01~12，例如：7                 |
|      %p      | 上/下午       | AP，PM，例如：PM               |
|      %M      | 分钟          | 00~59，例如：26                |
|      %S      | 秒            | 00~59，例如：26                |

`strftime(tpl, ts)`

- `tpl`是格式化模板字符串，用来定义输出效果,ts是计算机内部时间类型变量

```python
import time
tmp = time.strftime("%Y-%m-%d %H:%M:%S" , time.gmtime())
print(tmp)  # 2021-05-09 10:10:42
print(type(tmp))  # <class 'str'>
```

`strpitime(str, tpl)`

- `str`是字符串形式的时间值
- `tpl`是格式化模板字符串，用来定义输入效果

```python
import time
tmp = time.strptime("2021-07-09 18:21:31", "%Y-%m-%d %H:%M:%S") 
print(tmp)  # time.struct_time(tm_year=2021, tm_mon=7, tm_mday=9, tm_hour=18, tm_min=21, tm_sec=31, tm_wday=4, tm_yday=190, tm_isdst=-1)
print(type(tmp))  # <class 'time.struct_time'>
```



`sleep(s)`

- `s`是休眠的时间，单位是秒，可以是浮点数

```python
import time
start = time.perf_counter()
time.sleep(1)
end = time.perf_counter()
print("程序打印用时{:.10f}".format(start - end))  # 程序打印用时-1.0118159000
```



### 随机数

`seed(a=None)`

- 初始化给定的随机种子，默认为当前系统时间

```python
import random as rd

rd.seed(10)  # 给定种子情况下，随机数是可以复现的
tmp = rd.random()
print(tmp)  # 0.5714025946899135
print(type(tmp))  # <class 'float'>
```

`randome()`

- 生成一个`[0.0, 1.0]`之间的随机小数

```python
import random as rd

tmp = rd.random()
print(tmp)  # 0.22985667275294253
print(type(tmp))  # <class 'float'>

```

`randint(a, b)`

- 生成一个`[a, b]`之间的整数

```python
import random as rd

tmp = rd.randint(1, 10)
print(tmp)  # 0.4
print(type(tmp))  # <class 'int'>
```



`randrange(m, n[,k])`

- 生成一个`[m, n ]`之间以`k`为步长的随机整数

```python
import random as rd

tmp = rd.randrange(1, 10, 3)
print(tmp)  # 0.4
print(type(tmp))  # <class 'int'>
```



`getrandbits(k)`

- 生成一个`k`比特长的随机整数

```python
import random as rd

tmp = rd.getrandbits(16)
print(tmp)  # 12592
print(type(tmp))  # <class 'int'>
```



`uniform(a, b)`

- 生成一个`[a, b]`之间的随机整数

```python
import random as rd

tmp = rd.uniform(10, 100)
print(tmp)  # 44.01421656979518
print(type(tmp))  # <class 'float'>
```



`choice(seq)`

- 从序列`seq`中随机选择一个元素

```python
import random as rd

tmp = rd.choice(["a", "b", 2, 4, 6])
print(tmp)  # 2
print(type(tmp))  # <class 'int'>
```



`shuffle(seq)`

- 将序列`seq`中元素随机排列，返回打乱后的序列

```python
import random as rd

tmp = [1, 2, 3, 4, 5, 6, 7, 8]; rd.shuffle(tmp)
print(tmp)  # [6, 3, 1, 2, 5, 4, 8, 7]
print(type(tmp))  # <class 'list'>
```



### 集合

`S.add(x)`

- 如果`x`不在集合`S`中，将`x`增加到`S`

```python
tmp = {1, 1, 1, 2, 3, 4}
tmp.add('a') 
print(tmp)  # {1, 2, 3, 4, 'a'}
print(type(tmp))  # <class 'set'>
```

`S.discard(x)`

- 移除`S`中元素`x`，如果`x`不在集合`S`集合中，不报错

```python
tmp = { 1, 2, 3, 4}
tmp.discard(5)
print(tmp)  # {1, 2, 3, 4}
print(type(tmp))  # <class 'set'>
```

`S.remove(x)`

- 移除`S`中元素`x`,如果`x`不在集合`S`中,产生KeyError异常

```python
tmp = { 1, 2, 3, 4}
tmp.remove(5)
print(tmp)
print(type(tmp))

'''
Traceback (most recent call last):
  File "E:/pythonDemo/jcstore-v2/Pytest.py", line 2, in <module>
    tmp.remove(5)
KeyError: 5
'''
```

`S.clear()`

- 移除`S`中所有元素

```python
tmp = { 1, 2, 3, 4}
tmp.clear()
print(tmp)  # set()
print(type(tmp))  # <class 'set'>
```

`S.pop()`

- 随机返回S的一个元素，更新S，若S为空产生KeyError异常

```python
tmp = { 1, 2, 3, 4}
tmp.pop()
print(tmp)  # {2, 3, 4}
print(type(tmp))  # <class 'set'>
```

`S.copy()`

- 返回一个集合`S`的一个副本

```python
tmp = { 1, 2, 3, 4}
test = tmp.copy()
print(test)  # {1, 2, 3, 4}
print(type(test))  # <class 'set'>
```



### 序列

`len(s)`

- 返回序列`s`的长度

```python
tmp = [1, 2, 3, 4, 5]
print(len(tmp)) # 5
```

`min(s)`

- 返回序列`s`的最大元素，s的元素需要可比较

```python
tmp = [1, 2, 3, 4, 5]
print(min(tmp)) # 1
```

`max(s)`

- 返回序列`s`的最大元素,`s`的元素需要可比较

```python
tmp = [1, 2, 3, 4, 5]
print(max(tmp)) # 5
```

`s.index(x) 或 s.index(x, i, j)`

- 返回序列`s`到`i`开始到`j`位置中第一次出现元素`x`的位置,<font color='red'>左闭右开</font>

```python
tmp = [1, 2, 3, 4, 5]
print(tmp.index(4)) # 3
print(tmp.index(2, 0, 4)) # 1
```

`s.count(x)`

- 返回序列s中出现x的总次数

```python
tmp = [1, 2, 3, 4, 5, 5]
print(tmp.count(5)) # 2
```



### 列表

`ls[i = x]`

- 替换列表`ls`第`i`元素为`x`

```python
tmp = [1, 2, 3, 4, 5]
tmp[0] = "str"
print(tmp)  # ['str', 2, 3, 4, 5]
print(type(tmp))  # <class 'list'>
```



`ls[i:j:k] = lt`

- 用列表`lt`替换`ls`切片后对应元素子列表

```python
tmp = [1, 2, 3, 4, 5]
tmp[0: 2] = "str"
print(tmp)  # ['s', 't', 'r', 3, 4, 5]
print(type(tmp))  # <class 'list'>
```



`del ls[i]`

- 删除列表`ls`中第`i`元素

```python
tmp = [1, 2, 3, 4, 5]
del tmp[0]
print(tmp)  # [2, 3, 4, 5]
print(type(tmp))  # <class 'list'>
```



`del ls[i: j: k]`

- 删除列表`ls`第`i`到第`j`以`k`为步长的元素

```python
tmp = [1, 2, 3, 4, 5]
del tmp[0: 2]
print(tmp)  # [3, 4, 5]
print(type(tmp))  # <class 'list'>
```



`ls += lt`

- 更新列表`ls`，将列表`lt`元素增加到列表`ls`中

```python
tmp = [1, 2, 3, 4, 5]
tmp_a = "abcdefg"
tmp += tmp_a
print(tmp)  # [1, 2, 3, 4, 5, 'a', 'b', 'c', 'd', 'e', 'f', 'g']
print(type(tmp))  # <class 'list'>
```



`ls *= n`

- 更新列表`ls`, 其元素重复`n`次

```python
tmp = [1, 2, 3, 4, 5]
tmp *= 2
print(tmp)  # [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
print(type(tmp))  # <class 'list'>
```



`ls.append(x)`

- 在列表`ls`中增加元素`x`

```python
tmp = [1, 2, 3, 4, 5]
tmp.append('abcd')
print(tmp)  # [1, 2, 3, 4, 5, 'abcd']
print(type(tmp))  # <class 'list'>
```



`ls.clear()`

- 删除列表`ls`中所有元素

```python
tmp = [1, 2, 3, 4, 5]
tmp.clear()
print(tmp)  # []
print(type(tmp))  # <class 'list'>
```



`ls.copy`

- 生成一个新列表，赋值`ls`中所有元素

```python
tmp = [1, 2, 3, 4, 5]
tmp_a = tmp.copy()
print("tmp的信息：")
print(tmp)  # [1, 2, 3, 4, 5]
print(id(tmp))  # 1992890122816
print(type(tmp))  # <class 'list'>
print("tmp_a的信息：")
print(tmp_a)  # [1, 2, 3, 4, 5]
print(id(tmp_a))  # 1992891399680
print(type(tmp_a))  # <class 'list'>
```



`ls.insert(i,x)`

- 在列表`ls`的第`i`位置增加元素`x`

```python
tmp = [1, 2, 3, 4, 5]
tmp.insert(2, 'a')
print(tmp)  # [1, 2, 'a', 3, 4, 5]
print(type(tmp))  # <class 'list'>
```



`ls.pop(i)`

- 在列表`ls`中第`i`位置元素去除并删除该元素

```python
tmp = [1, 2, 3, 4, 5]
tmp.pop(3)
print(tmp)  # [1, 2, 3, 5]
print(type(tmp))  # <class 'list'>
```



`ls.remove(x)`

- 在列表`ls`中出现的第一个元素`x`删除

```python
tmp = [1, 2, 3, 4, 5]
tmp.remove(3)
print(tmp)  # [1, 2, 4, 5]
print(type(tmp))  # <class 'list'>
```



`ls.reverse()`

- 将列表`ls`中的元素反转

```python
tmp = [1, 2, 3, 4, 5]
tmp.reverse()
print(tmp)  # [5, 4, 3, 2, 1]
print(type(tmp))  # <class 'list'> 
```



`sorted(ls)`

- 将列表`ls`排序

```python
tmp = [3, 2, 1, 4]
tmp_b = sorted(tmp)
print(tmp_b)  # [1, 2, 3, 4]
print(type(tmp_b))  # <class 'list'>
```



`ls.sort(cmp=None, key=None, reverse=False)`

> [学习地址](https://www.runoob.com/python/att-list-sort.html)
>
> 对原列表进行排序

- key -- 传入一个方法，每次调用这个方法获取值比较
- reverse -- 排序规则，**reverse = True** 降序， **reverse = False** 升序（默认）。

```python
def get_value(ls):
    return ls[1]
'''以二维列表中的第二个值进行排序比较'''
tmp = [[1, 2], [4, 5], [9, 1], [10, 4]]
# tmp.sort(key=lambda x:x[1], reverse=True)
tmp.sort(key=get_value, reverse=True)
print(tmp)  # [[4, 5], [10, 4], [1, 2], [9, 1]]
print(type(tmp))
```



### 字典

`del d[k]`

- 删除字典d中键对应的数据值

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
del tmp[18]
print(tmp)  # {25: '李四', 36: '王五'}
print(type(tmp))  # <class 'dict'>
```



`k in d`

- 判断键`k`是否在字典`d`中，如果在返回`True`， 否则`False`

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = 18 in tmp
print(tmp_a)  # True
print(type(tmp_a))  # <class 'bool'>
```



`d.keys()`

- 返回字典`d`中所有的键信息

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = tmp.keys()
print(tmp_a)  # dict_keys([18, 25, 36])
print(type(tmp_a))  # <class 'dict_keys'>
```



`d.values()`

- 返回字典`d`中所有的值信息

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = tmp.values()
print(tmp_a)  # dict_values(['张三', '李四', '王五'])
print(type(tmp_a))  # <class 'dict_values'>
```



`d.items()`

- 返回字典`d`中所有的键值对信息

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = tmp.items()
print(tmp_a)  # dict_items([(18, '张三'), (25, '李四'), (36, '王五')])
print(type(tmp_a))  # <class 'dict_items'>
```



`d.get(k, <default>)`

- 键`k`存在，则返回相应值，不在则返回`<default>`值

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = tmp.get(28)
print(tmp_a)  # None
print(type(tmp_a))  # <class 'NoneType'>
```



`d.pop(k, <default>)`

- 键`k`存在，则取出相应值，不在则返回`<default>`值

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = tmp.pop(18)
print(tmp_a)  # 张三
print(tmp)  # {25: '李四', 36: '王五'}
print(type(tmp))  # <class 'dict'>
```



`d.popitem`()

- 随机从字典`d`中取出一个键值对，以元组形式返回

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = tmp.popitem()
print(tmp_a)  # (36, '王五')
print(type(tmp_a))  # <class 'tuple'>
print(tmp)  # {18: '张三', 25: '李四'}
print(type(tmp))  # <class 'dict'>
```



`d.clear()`

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp.clear()
print(tmp)  # {}
print(type(tmp))  # <class 'dict'>
```



`len(d)`

- 返回字典`d`中元素的个数

```python
tmp = {18: "张三", 25: "李四", 36: "王五"}
tmp_a = len(tmp)
print(tmp_a)  # 3
print(type(tmp_a))  # <class 'int'>
```

### os

> os库提供通用的、基本的操作胸痛交互功能
>
> os库是Python标准库，包含几百个函数
>
> 常用路径操作、进程管理、环境参数等几类问题

 **`op.path`**

> `os.path`子库以`path`为入口，用于操作和处理文件路径

`os.path.abspath(path)`

- 返回`path`再当前系统中的绝对路径

```python
import os.path as op
test = op.abspath('test.txt')
print(test)  # E:\pythonDemo\jcstore-v2\test.txt
print(type(test))  # <class 'str'>
```

`os.path.normpath()`

- 归一化`path`的表示方式，统一用`\\`分隔路径

```python
import os.path as op
test = op.normpath('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # E:\pythonDemo\jcstore-v2\test.txt
print(type(test))  # <class 'str'>
```

`os.path.relpath(path)`

- 返回当前程序与文件之间的相对路径(`relative path`)

```python
import os.path as op
test = op.relpath('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # test.txt
print(type(test))  # <class 'str'>
```

`os.path.basename(path)`

- 返回`path`中的文件名称

```python
import os.path as op
test = op.basename('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # test.txt
print(type(test))  # <class 'str'>
```

`os.path.dirname(path)`

- 返回`path`中的目录名称

```python
import os.path as op
test = op.dirname('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # E:\pythonDemo\jcstore-v2
print(type(test))  # <class 'str'>
```

`os.path.join(path)`

- 组合`path`与`paths`,返回一个路径字符串

```python
import os.path as op
test = op.join('E:\\', 'pythonDemo\\jcstore-v2\\test.txt')
print(test)  # E:\pythonDemo\jcstore-v2\test.txt
print(type(test))  # <class 'str'>
```

`os.path.exists(path)`

- 判断`path`对应文件或目录是否存在，返回`True`或`False`

```python
import os.path as op
test = op.exists('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # True
print(type(test))  # <class 'bool'>
```

`os.path.isfile(path)`

- 判断`path`对应是否为已存在的文件，返回`True`或`False`

```python
import os.path as op
test = op.isfile('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # True
print(type(test))  # <class 'bool'>
```

`os.path.isdir(path)`

- 判断`path`对应是否为已存在的目录，返回`True`或`False`

```python
import os.path as op
test = op.isdir('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # False
print(type(test))  # <class 'bool'>
```

`os.path.getatime(path)`

- 返回`path`对应文件或目录上一次的访问时间

```python
import os.path as op
import time
test = op.getatime('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # 1621691486.8812747
print(type(test))  # <class 'float'>  # <class 'float'>
print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(test)))  # 2021-05-22 21:51:26
```

`os.path.getmtime(path)`

- 返回`path`对应文件或目录最近一次的修改时间

```python
import os.path as op
import time
test = op.getmtime('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # 1621691472.2872932
print(type(test))  # <class 'float'>  # <class 'float'>
print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(test)))  # 2021-05-22 21:51:12
```

`os.path.getmtime(path)`

- 返回`path`对应文件或目录的创建时间

```python
import os.path as op
import time
test = op.getctime('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # 1621678251.9427152
print(type(test))  # <class 'float'>  # <class 'float'>
print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(test)))  # 2021-05-22 18:10:51
```

`os.path.getsize(path)`

- 返回`path`对应文件的大小，以字节为单位

```python
import os.path as op
test = op.getsize('E:\\pythonDemo\\jcstore-v2\\test.txt')
print(test)  # 246
print(type(test))  # <class 'int'>
```

**系统操作**

`os.chdir()`

- 修改当前程序操作的路径

```python
import os
os.chdir('E:\\pythonDemo')
test = os.getcwd()
print(test)  # E:\pythonDemo
print(type(test))  # <class 'str'>
```

`os.getcwd()`

- 返回程序的当前路径

```python
import os
test = os.getcwd()
print(test)  # E:\pythonDemo\jcstore-v2
print(type(test))  # <class 'str'>
```

`os.getlogin()`

- 获得当前系统登录用户名称

```python
import os
test = os.getlogin()
print(test)  # sorry_le
print(type(test))  # <class 'str'>
```

`os.getlogin()`

- 获得当前系统登录用户名称

```python
import os
test = os.getlogin()
print(test)  # sorry_le
print(type(test))  # <class 'str'>
```

`os.cpu_count()`

- 获得当前系统的`CPU`数量

```python
import os
test = os.cpu_count()
print(test)  # 12
print(type(test))  # <class 'int'>
```

`os.path.cpu_count()`

- 获得当前系统的`CPU`数量

```python
import os
test = os.unandom()
print(test)  # 12
print(type(test))  # <class 'int'>
```

`os.path.urandom(n)`

- 获得`n`各字节长度的随机字符串，通常用于加解密运算

```python
import os
test = os.urandom(10)
print(test)  # b'a\xdf(*\xc7Q\xdf\x9bE{'
print(type(test))  # <class 'bytes'>
```



### 文件

`<变量名> = open(<文件名>, <打开模式>)`

- `变量名` - 是操作文件的句柄，不管是读写都用这个句柄进行操作
- `文件名` - 是文件的路径, 例子：`D:/PYE/f,txt` 或者 `D:\\PYE\\f.txt`
- `打开模式` - 文本 or 二进制，读 or 写

| 文件的打开模式 | 描述                                                      |
| :------------: | --------------------------------------------------------- |
|      ‘r’       | 只读模式，默认值，如果文件不存在，返回`FIleNotFoundError` |
|      ‘w’       | 覆盖写模式,文件不存在则创建，存在则完全覆盖               |
|      ‘x’       | 创建写模式，文件不存在则创建，存在则返回`FileExistsError` |
|      ‘a’       | 追加写模式，文件不存在则创建，存在则在文件最后追加内容    |
|      ‘b’       | 二进制文件模式                                            |
|      ‘t’       | 文本文件模式，默认值                                      |
|      ‘+’       | 与`r/w/x/a`一同使用，在原功能基础上增加同时读写功能       |

`test.txt`文件内容

```text
中国是一个伟大的国家!
是的
```



`<f>.read()`

- 读入全部内容，如果给出参数，则读取前`size`长度

```python
tmp = open('./test.txt', 'r', encoding='UTF-8')
text = tmp.read(2)
print(text)  # 中国
print(type(text))  # <class 'str'>
```



`<f>.readline()`

- 读入一行内容，如果给出参数，读入该行前`size`长度

```python
tmp = open('./test.txt', 'r', encoding='UTF-8')
text = tmp.readline()
print(text)  # 中国 
print(type(text))  # <class 'str'>
```



`<f>.readlines()`

- 读入文件所有行，以每行为元素形成列表
- 如果给出参数，读入前hint行

```python
tmp = open('./test.txt', 'r', encoding='UTF-8')
text = tmp.readlines()
print(text)  # ['中国是一个伟大的国家!\n', '是的\n', '赞同']
print(type(text))  # <class 'list'>
```



`<f>.write(s)`

- 向文件写入一个字符串和字节流

`<f>.writelines(lines)`

- 将一个元素全为字符串的列表写入文件

```python
ls = ['\n', '中国', '美国', '法国']
tmp = open('./test.txt', 'r+', encoding='UTF-8')
tmp.writelines(ls)
print(tmp.readlines())  # ['中国是一个伟大的国家!\n', '是的\n', '赞同']
print(type(tmp))  # <class '_io.TextIOWrapper'>
```



`<f>.seek(offset)`

- 改变当前文件操作指针的位置，`offset`含义如下：0  文件开头; 1 当前位置；2 文件结尾



### socket 

[学习地址](https://www.runoob.com/python/python-socket.html)

> Socket又称"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。

**通用方法**

`socket.socket()`

- 创建套接字

`bind((host, port))`

- 绑定地址`host`和端口`port`到套接字中，以元组`(host, port)`的形式表示地址

`recv(bufsize)`

- 接收`TCP`数据，数据以字符串形式返回，`bufsize`指定要接收的最大数据量。

`send(string)`

- 发送`TCP`数据，将`string`发送到连接的套接字。返回值时要发送的字节数量，该数量可能小于`string`的字节大小

`sendall(string)`

- 完整发送 `TCP `数据。将 `string `中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回 `None`，失败则抛出异常。

`recvfrom()`

- 接收 `UDP `数据，与 `recv() `类似，但返回值是`（data,address）`。其中 `data `是包含接收数据的字符串，`address `是发送数据的套接字地址。

`sendto()`

- 发送 `UDP `数据，将数据发送到套接字，`address `是形式为`（ipaddr，port）`的元组，指定远程地址。返回值是发送的字节数。

`settimeout(timeout)`

-  设置套接字操作的超时期，`timeout`是一个浮点数，单位是秒。值为`None`表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如`connect()`）

`setsockopt(level,optname,value)` - [学习地址](https://www.cnblogs.com/clschao/articles/9588313.html)

- 设置给定套接字选项的值。

`setblocking(flag)`

- 如果`flag`为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用`recv()`没有发现任何数据，或`send()`调用无法立即发送数据，那么将引起`socket.error`异常。

`s.close()`

- 关闭套接字

## socket()

**服务端方法**

`listen(number)`

- 开始`TCP`监听。`number`指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用层序设为5。

`accept()`

- 被动接收`TCP`客户端连接，（阻塞式）等待连接的带来

```python
import socket

se = socket.socket()  # # 创建套接字
se.bind(('localhost', 8083))  # 绑定ip地址和端口
se.listen(5)  # 监听，并且指定最大连接排队数
while 1:
    connection, addr = se.accept()  # 被动接收客户端连接
    try:
        data = connection.recv(2048)  # 获取连接传输的数据，最长2048字节
        print(data.decode('utf-8'))  # 以utf-8解码后打印
        connection.send('2.找我干嘛？'.encode('utf-8'))  # 数据以utf-8编码h后发送 
    except Exception as e:
        connection
    connection.close() # 关闭连接

    
'''
<socket.socket fd=1120, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8083), raddr=('127.0.0.1', 9999)>            ('127.0.0.1', 9999)
1.喂！
2.找我干嘛？
'''
```



**客户端方法**

`connect(address)`

- 主动初始化`TCP`服务器连接，。一般address的格式为元组`（host,port）`，如果连接出错，返回`socket.error`错误。

`connect_ex()`

- ` connect()`函数的扩展版本,出错时返回出错码,而不是抛出异常

`getsockopt(level,optname[.buflen])`

- 返回套接字选项的值。

`gettimeout()`

- 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

`fileno()`

- 返回套接字的文件描述符。

```python
import  socket
# 创建一个socket
cl = socket.socket()
# 绑定端口，地址
cl.bind(('localhost', 9999))
# 连接至对端端口和地址
cl.connect(('localhost', 8083))

# 把数据以utf-8编码后发送，避免编码不同导致乱码
send_data = '1.喂！'
cl.send(send_data.encode('utf-8'))

# 接收数据以utf-8解码打印，避免编码不同导致乱码
data = cl.recv(2048)
print(data.decode('utf-8'))

# 关闭连接
cl.close()


'''
<socket.socket fd=1120, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8083), raddr=('127.0.0.1', 9999)>            ('127.0.0.1', 9999)
1.喂！
2.找我干嘛？
'''
```

**通用方法获取信息**

`getpeername()`

- 返回连接套接字的远程地址。返回值通常是元组`（ipaddr,port）`。

`getsockname()`

- 返回套接字自己的地址。通常是一个元组`(ipaddr,port)`

`makefile()`

- 创建一个与该套接字相关连的文件

## 关键字

| raise | nolocal | assert | is   |
| ----- | ------- | ------ | ---- |
| class | with    | yield  |      |
|       |         |        |      |
|       |         |        |      |

## 程序设计

### IPO

- 确定IPO：明确计算部分及功能边界
- 编写程序：将计算求解的设计变成现实
- 调试程序：确保程序按照正确逻辑能够正确运行



### 模块化设计的思想

**分而治之**

- 通过函数或对象封装程序划分为模块及模块之间的表达
- 具体包括：主程序、子程序和子程序间的关系
- 分而治之：一种分而治之、分层抽象、体系化的设计思想

-**紧耦合**：两个部分之间交流很多，无法独立存在

-**松耦合**：两个部分之间交流较少，可以独立存在

> 模块内部紧耦合、模块之间松耦合

### 配置设计

- 、**引擎+配置**：程序执行和配置分离，将可选参数配置化
- 将程序开发变成配置文件编写，扩展功能而不修改程序
- 关键在于接口设计，清晰明了、灵活可扩展



### 分析方法

**自顶向下**（设计）

- 将一个总问题表达为若干个小问题组成的形式
- 使用同样方法进一步分解小问题
- 直至，小问题可以用计算机简单明了的解决

**自底向上（执行）**

- 分单元测试，逐步组装
- 按照自顶向下相反的路径操作
- 直至，系统各部分以组装的思路都经过测试和验证



### 思维特征

- 逻辑思维：推理和演绎，数学为代表，若A->B B->C 则A->C
- 实证思维：实验和验证，物理为代表，提出引力波假说<-大量实验证实

**计算思维**

> 设计和构造，计算机为代表，汉诺塔递归

- 抽象和自动化
  - 抽象问题的计算过程，利用计算机自动化分解
  - 抽象时基于计算机的思维方式
- 抽象问题的计算过程，利用计算机自动化求解
  - 计算思维基于计算机强大的算力及海量数据
  - 抽象计算过程，关注设计和构造，而非因果
  - 以计算机程序设计为实现的主要手段



### 应用开发

- **产品定义：**对应用需求充分理解和明确定义产品定义，而不仅时功能定义，要考虑商业模式
- **系统架构：**以系统方式思考产品的技术实现系统架构，关注数据流、模块化、体系架构
- **设计与实现：**结合架构完成关键设计及系统实现结合可扩展性、灵活性等进行设计优化
- **用户体验：**从用户角度思考应用效果，用户至上，体验优先，以用户为中心



### 用户体验

**思维转变：**实现功能 -> 关注体验

> 用户体验指产品建立的主观感受和认识
>
> 关心功能实现，更要关系用户体验，才能做好产品
>
> 编程只是啥都按，不是目的，程序最终为人类服务

1. **进度展示** 
   -  如果程序需要计算时间，可能产生等待，请增加进度条  -  循环可能会消耗大量时间，需要增强交互
   - 如果程序有若干步骤，需要提示用户，请增加进度展示  - 提示用户下一步或还剩多少步
   - 如果程序可能存在大量次数的循环，请增加进度条   -   循环可能会消耗大量时间，需要增强交互
2. **异常处理**
   - 当获得用户输入，对合规性需要检查，需要异常处理
   - 当读写文件时，对结果进行判断，需要异常处理
   - 对进行输入输出时，对运算结果进行判断，需要异常处理
3. **其他类方法**
   - 打印输出：特定位置，输出程序运行的过程信息
   - 日志文件：对程序异常及用户使用进行定期记录
   - 帮助信息：给用户多种方式提供帮助信息

## 程序设计基础

**程序设计基本方法**

计算机是根据指令操作数据的设备

- 功能性：对数据的操作，表现为数据计算、输入输出处理和结果存储等
- 可编程性：根据一系列指令自动地、可预测地、准确地完成操作者的意图

计算机的发展参照摩尔定律，表现为指数方式

- 计算机硬件所依赖的集成电路规模参照摩尔定律发展
- 计算机运行速度因此也接近几何级数快速增长
- 计算机所能高效支撑的各类运算功能不断丰富发展

摩尔定律Moore‘s Law

- Intel公司创始人之一戈登·摩尔在1964年提出
- 单位面积集成电路可容纳晶体管的数量约每两年翻一番
- GPU/CPU、内存、硬盘、电子产品价格等都遵守摩尔定律

计算机的发展

- 当今世界，唯一长达50 年有效且按照指数发展的技术领域
- 计算机深刻改变人类社会，甚至可能改变人类本身
- 可预见的未来30年，摩尔定律还将持续有效

程序设计是计算机可编程性的体现

- 程序设计，亦称编程，深度应用计算机的主要手段
- 程序设计已经成为当今社会需求量最大的职业技能之一
- 很多岗位都将被计算机程序接管，程序设计将是生存技能



**编程语言基础概念**

源代码：采用某种编程语言编写的计算机程序，人类可读

> 例如: `result = 2+3`

目标代码：计算机课直接执行，人类不可读

> 例如：11010010 0011011

**编译**：将源代码一次性转换成目标代码的过程

![image-20210425204434892](/assets/images/2021/2021-05-12-Python/image-20210425204434892.png)

**解释：**将源代码逐条转换成目标代码同时逐条运行的过程

![image-20210425204524006](/assets/images/2021/2021-05-12-Python/image-20210425204524006.png)



**静态语言：**使用编译执行的编程语言C/C++、JAVA语言

- 编译器一次性生成目标代码，优化更充分，程序运行速度更快

**脚本语言：**使用解释器执行的编程语言：Python、JavaScript、PHP

- 执行程序过程时需要源代码，维护更灵活，源代码在维护灵活、跨多个操作系统平台



**程序的基本编写方法**

> **理解IPO**

**输入/Input：**程序的输入，输入是程序开始

- 文件输入、网络输入、控制台输入、交互界面输入、内部参数输入等

 输出/Output：程序的输出，输出是程序展示运算结果的方式

- 控制台输出、图形输出、文件输出、网络输出、操作系统内部变量输出等

**处理/Process：**处理时程序输入数据进行计算产生输出结果的过程

- 处理方法统称为算法，它是程序最重要的不发

- 算法是一个程序的灵魂

 问题的计算部分：一个待解决问题中，可以用程序辅助完成的部分

- 计算机只能计算问题，既问题的计算部分
- 一个问题可能有多种角度理解，产生不同的计算部分
- 问题的计算部分一般都有输入、处理和输出过程

> **编程解决问题的步骤**

1. 分析问题：分析问题的计算部分，想清楚
2. 划分边界：划分问题的功能边界，规划IPO
3. 设计算法：设计问题的求解算法，关注算法
4. 编写程序：编写问题的计算程序，编程序
5. 调试测试：调试程序使正确运行，运行调试
6. 升级维护：适应问题的升级维护，更新完善

> **求解计算机问题的精简步骤**

- 确定IPO：明确计算部分及功能边界

- 编写程序：将计算求解的设计编程现实
  - 调试程序：确保程序按照正确逻辑能够正确运行 



**Python的两种编程方式**

IDLE练习Python语法

交互式和文件式

- 交互式：对每个输入语句即时运行结果，适合语法练习
- 文件式：批量执行一组语句并运行结果，编程的主要方式





**实例**

**温度转换**：温度刻画的两种不同体系

- 摄氏度：中国等世界大多数国家使用
  - 以1标准大气压下水的结冰点为0度，沸点为100度，将温度进行等分刻画
- 华氏度：美国、英国等国家使用
  - 以1标准大气压下水的结冰点为32位，沸点位212度，将温度进行等分刻画

**需求分析**：两种温度体系的转换

- 摄氏度转换为华氏度
- 华氏度转换为摄氏度

**问题分析**：该问题计算部分的理解和确定

- 理解1：直接将温度值进行转换
- 理解2：将温度信息发布的声音或图像形式进行理解和转换
- 理解3：监控温度信息发布渠道，实时获取并转换温度值

**采用理解1**：直接将温度值进行转换

- 温度数值需要标明温度体系，既摄氏度或华氏度
- 转换后也需要给出温度体系

**划分边界**

- 输入： 带华式或摄氏标志的温度值
- 处理：根据温度标志选择适当的温度转换算法
- 输出：带摄氏或华式标志的温度值

**输入输出格式设计**

- 标识放在温度最后，F表示华式度，C表示摄氏度
- 82F表示华式82度，28C表示摄氏28度

**设计算法**

根据华式和摄氏温度定义，利用转换公式如下：
$$
C = (F - 32) \div 1.8 \\
F = C \times 1.8+32
$$

```python
TempStr = input("请输入带有符号的温度值:")
if TempStr[-1] in ['F', 'f']:
    C = (eval(TempStr[0:-1]) -32)/1.8
    print("转换后的温度是{:.2f}C".format(C))
elif TempStr[-1] in ['C', 'c']:
    F = 1.8 * eval(TempStr[0:-1]) + 32
    print("转换后的温度是{:.2f}F".format(F))
else:
    print("输入格式错误")
```





## 数据类型

### **整数数据类型**

> **四种进制的表示形式**

- 十进制：1010，99，-23
- 二进制，以0b0B或开头：0b010，-0b101
- 八进制，以0o或0O开头：0o872，-0O123
- 十六进制,以0x或0X开头：0x9a，-0X89



### **浮点数类型**

浮点数的取值范围和小数进度都存在限制，但常规计算可忽略

取值范围数量级约`-10^308` 至$10^308$，精度数量级$10^{-16}$

> 浮点数间运算存在不确定尾数，浮点数在计算中以53位二进制表示，

**0.1表示**

二进制表示:`0.00011001100110011001100110011001100110011001100110011010`

十进制表示：`0.100000000000000055511151231257827021181583404541015625`

> 二进制表示小数可以无限接近，但不完全相同

<font color='red'>**浮点数的运算需要使用round函数**</font>



> **浮点数可以采用科学计数法表示**

使用`e`或`E`作为幂的符号，以10为技术，格式如下：`aEb`  表示:$a*10^b$

例如：`4.3e-3`值为0.0043  `9.6E5`值为960000.0



### **复数类型**

与数学中复数的概念一致

如果$x^2= -1$，那么x的值是什么

- 定义$j=\sqrt{(-1)}$，以此为基础，构建数学体系

- $a+b_j$被称为复数，其中，a是实部，b是虚部

> **复数实例**

$z=1.23e-4+5.6e+89j$

实部是什么？``z.real`获得实部（$1.23e-4$)

虚部是什么？`z.imag`获得虚部($5.6e+89j$)

```python
z=1.23e-4+5.6e+89j
print(z.real) # 0.000123
print(z.imag) # 5.6e+89

```



**数值运算操作符**

| 操作符及使用 | 描述                                                         |
| :----------: | ------------------------------------------------------------ |
|    $x+y$     | 加，x与y之和                                                 |
|    $x-y$     | 减，x与y之差                                                 |
|    $x*y$     | 乘，x与y之积                                                 |
|    $x/y$     | 除，x与y之商 $10/3$结果是3.33333333335                       |
|    $x//y$    | 整数除，x与y之整数商$10//3$结果是3                           |
|     $+x$     | x本身                                                        |
|     $-y$     | y的负值                                                      |
|   $x \% y$   | 余数，模运算 $10 \% 3$结果是1                                |
|   $x ** y$   | `幂运算，x是y次幂`   分隔  ​` 当y是小数时，开方运算 10**0.5是`$\sqrt{10}$ |



**数字类型的关系**

三种类型存在一种逐渐`扩展`或`变宽`的关系：

> 整数 -> 浮点数 -> 复数





### **字符串**

字符串的定义

```python
print("字符串")  # 字符串
print('字符串')  # 字符串 
print('''字符串''')  # 字符串
print("""字符串""")  # 字符串
```

特殊字符串

`\n`- 换行

`\r` - 移至行首



### **序列**

- 序列的序号存在正向递增和反向递减
- 序列类型通用操作符

```python
tmp = [1, 2, 3, 4, 5]
# 正向递增序号
print(tmp[3]) # 4
# 反向递减序号
print(tmp[-3]) # 3
```

| 操作符及应用         | 描述                                               |
| -------------------- | -------------------------------------------------- |
| `x in s `            | 如果x是序列s的元素，返回True，否则返回False        |
| `x not in s`         | 如果x是序列s的元素，返回False，否则返回True        |
| `s + t`              | 连接两个序列s和t                                   |
| `s*n 或 n*s`         | 将序列s复制n次                                     |
| `s[i]`               | 索引，返回s中的第`i`个元素，`i`是序列的序号        |
| `s[i:j] 或 s[i:j:k]` | 切片，返回序列s中第`i`到`j`以`k`为步长的元素子序列 |

```python
tmp = [1, 2, 3, 4, 5]
tmp_a = [1, 2, 3, 4]

print(tmp + tmp_a) # [1, 2, 3, 4, 5, 1, 2, 3, 4]

print(tmp * 2) # [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]

print(tmp[-3])  # 3

print(tmp[1:3]) # [2, 3]

print(tmp[0:4:2]) # [1, 3]
```



### **`list`**

- 可以使用`list[-1]`获取倒数索引的值

```python
# 遍历文件，打印每一行的数据
tmp = open("F:\\tmp\\test.txt")
for i in tmp:
    print(i.strip("\n"), end=",") # 1,2,3,4,5,6,7,8,9,10,

```

### `tuple`

- 元组数据类型,元组以`,`定义数据

```python
tmp = 1, 2, 3, 4,
print(tmp)
print(type(tmp))

tmp = (1,)
print(tmp)
print(type(tmp))

tmp = (1) 
print(tmp) # 1
print(type(tmp)) # <class 'int'>
```





### **集合**

- 集合是多个元素的无须组合
- 集合类型与数据的集合概念一致
- 集合之间无须，每个元素唯一，不存在相同元素
- 集合元素<font color='red'>不可更改</font>，不能是可变数据类型

```python
tmp = {1, 1, 1, 2, 3, 4}
print(tmp)  # {1, 2, 3, 4}
print(type(tmp))  #  <class 'set'>


tmp = set()
print(tmp)  # set()
print(type(tmp))  # <class 'set'>
```

| 运算 | 操作符及应用 | 描述                                       |
| ---- | :----------: | ------------------------------------------ |
| 并   |     S\|T     | 返回一个新集合，包括在集合S和T中的所有元素 |
| 差   |     S-T      | 返回一个新集合，包括在集合S但不在T中的元素 |
| 交   |     S&T      | 返回一个新集合，包括同时在集合S和T中的元素 |
| 补   |     S^T      | 返回一个新集合，包括集合S和T中非相同元素   |
|      | S<=T 或 S<T  | 返回Ture/False,判断S和T的子集关系          |
|      | S>=T 或 S>T  | 返回True/False，判断S和T的包含关系         |

增强操作符

| 操作符及应用 | 描述                                  |
| :----------: | ------------------------------------- |
|    S\|=T     | 更新集合S，包括在集合S和T中的所有元素 |
|     S-=T     | 更新集合S，包括在集合S但不在T中的元素 |
|     S&=T     | 更新集合S，包括同时在集合S和T中的元素 |
|     S^=T     | 更新集合S，包括集合S和T中的非相同元素 |

```python
tmp = {1, 1, 1, 2, 3, 4}
print(tmp)  # {1, 2, 3, 4}
print(type(tmp))  # <class 'set'>

tms = {3, 'a'}

tmp -= tms
print(tmp)  # {1, 2, 4}
print(type(tmp))  # <class 'set'>
```



> 



## 数据组织的维度

**一维数据**

> 由对等关系的有序或无序数据构成，采用线性方式组织
>
> [3, 4, 5, 6]
>
> 对应列表、数组和集合等概念

**二维数据**

> 由多个一维数据构成，是一维数据到组合形式
>
> 一个列表的元素也是列表。

| 排名 | 总分  |
| :--: | :---: |
|  1   | 100分 |
|  2   |  49   |
|  3   |  45   |
|  4   |   1   |

**高维数据**

> 仅利用最基本的二元关系展示数据间的复杂结构

```python
{
    'name': '二狗',
    'info':{
        'age': 18,
    	'sex': '男'
           }
}
```





## 第三方库

### pip安装

> 安装Python的第三方库的主要方法
>
> 适合WInodws、Mac和Linux等操作系统
>
> 未来获取第三方库的方式，目前的主要方式
>
> 适合99%以上情况，需要联网安装

**联网安装**

- `pip -h`  - 查看帮助
- `pip install <第三方库名>` - 安装指定的第三方库
- `pip install -U <第三方库名>` - 使用更新已安装的指定第三方库
- `pip uninstall <第三方库名>` -卸载指定的第三方库
- `pip download <第三方库名>` - 下载但不安装指定的第三方库
- `pip search <关键字>` - 根据关键词在名称和介绍中搜索第三方库

**文件安装**

- 某些第三方库`pip`下载后，需要编译再安装
- 访问 [Python Extension Packages for Windows - Christoph Gohlke (uci.edu)](https://www.lfd.uci.edu/~gohlke/pythonlibs/)
- 下载需要安装的第三方库，执行`pip install`安装





- 精确模式：把文本精确的切分开，不存在冗余单词
- 全模式：把文本中所有看你的词语都扫描出来，有冗余
- 搜索引擎模式：在精确模式基础上，对长词再次切分

`jieba.lcut(s)`

- 精确模式，返回一个列表类型的分词结果

`jieba.lcut(s, cut_all=True)`

- 全模式，返回一个列表类型的分词结果，存在冗余

`jieba.lcut_for_search(s)`

- 搜索引擎模式，返回一个列表类型的分词结果，存在冗余

`jieba.add_word(w)`

- 向分词词典增加新词`w`

```python
import jieba
tmp = "中国是一个伟大的国家"
print(jieba.lcut(tmp)) # 精准模式
# ['中国', '是', '一个', '伟大', '的', '国家']
print(jieba.lcut(tmp, cut_all=True)) # 全模式
# ['中国', '国是', '一个', '伟大', '的', '国家']
print(jieba.lcut_for_search(tmp))  # 搜索引擎模式
# ['中国', '是', '一个', '伟大', '的', '国家']
jieba.add_word(tmp)
print(jieba.lcut(tmp))
# ['中国是一个伟大的国家']
```





**`wordcloud`**

- `wordcloud`库把词云当作一个`WordCloud`对象
- 可以根据文本词语出现的频率等参数绘制词云
- 绘制词云的形状、尺寸和颜色都可以设定

`w = wordcloud.WordCloud()`

- 创建一个词云对象

- `width`  - 宽度，默认400像素

- `height` - 高度，默认200像素

- `min_font_size` - 最小字号，默认4号

- `max_font_size` - 最大字号，根据高度自动调节

- `font_step` - 指定词云中字体字号的步进间隔，默认为1

- `font_path` - 指定字体文件的路径，默认为`None`，字体文件为`ttc`文件

- `max_words` - 指定词云显示的最大单词数量，默认200

- `stop_words` -  排除词集合，既不显示的单词集合

- `background_color` - 指定词云的背景颜色，默认为黑色

- `mask` - 生成特定形状的词云图片

  - ```python
    from scipy.misc import imread
    mask = imread('test.png') # test.png是一个白底的五角星图片
    wordcloud.WordCloud(mask=mask)
    ```

    

`w.generate(txt)`

- 向`WordCloud`对象`w`中加载`txt`

`w.to_file(filename)`

- 将词云输出为图像文件`.png`或`.jpg`

### pymysql

Python对Mysql数据的简单操作学习。

**安装pymysql**

使用pip安装pymysql，并且从清华大学源下载安装。

```bash
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/  pymysql 
```



**创建连接**

使用connect方法进行连接数据库

- host：ip地址
- port：端口
- user：数据库账号
- password：数据的密码
- database：连接的库名   注：你对那个库进行增删改查就连接那个库
- charset：字符集编码  注：选填，有些时候会因为字符集编码而出现问题, `utf8`没有`-`

```python
import pymysql
# 连接mysql，返回一个连接对象
connection = pymysql.connect(host="127.0.0.1", port=3306, user="root",
                       password="root",database="databasename", charset="utf8")

# 获取连接对象的游标
cursor = connection.cursor()
```



 **释放资源**

connection和cursor都有一个close方法释放资源，释放顺序为cursor、connection

```python
import pymysql
# 连接mysql，返回一个连接对象
connection = pymysql.connect(host="127.0.0.1", port=3306, user="root",
                       password="root",database="databasename", charset="utf8")
cursor.close()
connection.close()
```



 **执行SQL语句的方法**

所有的sql语句都用execute方法执行。

使用格式化参数可以预防SQL注入的安全问题；

<font color='red'>注意事项：</font>

- <font color='red'>不管mysql中什么数据类型，在格式化的源语句中都用%s，不要用%d,%f之类的</font>
- <font color='red'>编写SQL时不要忘记带结束符;</font>

- execute:执行SQL的方法
  - query: 执行的SQL语句
    - 类型：str
  - args：格式化参数列表
    - 类型：list

```python
import pymysql  # 导入 pymysql
# 打开数据库连接
connection = pymysql.connect(host="192.168.1.15", user="root",password="123456", db="jccloud", port=3306, charset='utf8')

# 使用cursor()方法获取操作游标
cursor = connection.cursor()
SQL = "SELECT *  FROM user WHERE name=%s AND age=%s"
cursor.execute(SQL, ['张三', 11])
```



**查询的方法**

执行查询时，会把查询到的所有记录存储在`二维元组`里并且返回。

查询多条记录时，指针的初始位置在第一位，如下表中，查询出时，指针指向id为1的数据

  **常用方法：**

- cursor.fetchall：获取所有数据，并且移动游标到最后一位
- cursor.fetchone：移动游标到后一位并取出数据

- cursor.scroll :移动游标
  - value：移动的偏移值。
  - mode：以什么模式移动
    - relative: 以当前位置为起点移动。
    - absolute: 以初始位置为起点移动。
- cursor.fetchmany：移动偏移值位并取出数据
  - value: 移动的偏移值 
  - int类型

| ID   | user | age  |
| ---- | ---- | ---- |
| 1    | 张三 | 11   |
| 2    | 李四 | 23   |

 **代码**

```python
import pymysql  # 导入 pymysql

# 打开数据库连接
connection = pymysql.connect(host="192.168.1.15", user="root",password="123456", db="jccloud", port=3306, charset='utf8')

# 使用cursor()方法获取操作游标
cursor = connection.cursor()
try:
    cursor.execute("select * from user;" )  # 执行sql语句
    results = cursor.fetchall()  # 获取查询的所有记录  results= ((1, '张三', '123456'), (2, '李四', '65431'))
    print("id", "name", "age")
    # 遍历结果
    for row in results:
        print(row[0], row[1], row[2])
except Exception as e:
    raise e
finally:
    cursor.close()  # 释放光标对象资源，免得内存泄漏
    connection.close()  # 释放连接的资源，免得内存泄漏
```

**执行结果：**

```
id name password
1 张三 123456
2 李四 654321
```



**增删改方法**

使用pymysql进行增删改的时候，会默认开启一个事务，所以操作时，务必要执行commit方法提交代码。

 **常用方法：**

- connection.commit：提交的方法，每次执行语句后都要使用该方法
- connection.rollback：回滚事物的方法
- cursor.lastrowid：获取插入记录的ID的方法

**举例：增**

**删改两种操作也是一样的步骤**

```python
import pymysql  # 导入 pymysql

# 打开数据库连接
connection = pymysql.connect(host="192.168.1.15", user="root", password="123456", db="jccloud", port=3306, charset='utf8')

cursor = connection.cursor() # 使用cursor()方法获取操作游标

try:
    cursor.execute("INSERT INFO user(name,age) VALUES(%s,%s);", ['张三', 80]) # 执行SQL语句
    connection.commit()  # 提交事务
    print('刚刚插入记录的ID是:',cursor.lastrowid)  # 获取刚刚插入的数据的ID,并且打印
except Exception as e:
    connection.rollback()  # 有异常，回滚事务
finally:
    cursor.close()  # 释放光标对象资源，免得内存泄漏
    connection.close()  # 释放连接的资源，免得内存泄漏

```

执行结果

```
刚刚插入记录的ID是: 3
```









## 计算生态

### **从数据处理到人工智能**

**数据分析**

`Numpy:`表达`N`维数组的最基础库 - [学习地址](http://www.numpy.org)

- `Python`接口使用，`C`语言实现，计算速度优异
- `Python`数据分析及科学计算的基础库，支撑`Pandas`等
- 提供直接的矩阵运算、广播函数、线性代数功能

`Pandas:Python`数据分析高层次应用库 - [学习地址](http://pandas.pydata.org)

- 提供了简单易用的数据结构和数据分析工具
- 理解数据类型和索引的关系，操作索引既操作数据
- `Python`最主要的数据分析功能库，基于`Numpy`开发

`SciPy:`数学、科学和工程计算功能库 - [学习地址](http://www.scipy.org)

- 提供了一批数学算法及工程运算的功能
- 类似`Matlab`，可用于如博里叶变换、信号处理等应用
- `Python`最主要的科学计算功能库，基于`Numpy`开发

**数据可视化**

`Matplotlib:`高质量的二维数据可视化功能库 - [学习地址](http://matplotlib.org/)

- 提供了超过100种数据可视化展示效果
- 通过`matplotlib.pyplot`子库调用各可视化效果
- `Python`最主要的数据可视化功能库，基于`Numpy`开发

`Seaborn:`  统计类数据可视化功能库 - [学习地址](http://seaborn.pydata.org/)

-  提供了一批高层次的统计类数据可视化展示效果
- 主要展示数据间分布、分类和线性关系等内容
- 基于`Matplotlib`开发，支持`Numpy`和`Pandas`

`Mayavi:`三维科学数据可视化功能库 - [学习地址](http://docs.enthought.com/mayavi/mayavi/)

- 提供了一批简单易用的`3D`科学计算数据可视化展示效果
- 目前版本是`Mayavi2`，三维可视化最主要的第三方库
- 支持`Numpy`、`TVTK`、`Traits`、`Envisage`等第三方库

**文本处理**

`PyPDF2:`用来处理`pdf`文件的工具集 - [学习地址](http://mstamy2.github.io/PyPDF2)

- 提供了一批处理PDF文件的计算功能 
- 支持获取信息、分隔/整合文件、加密解密等
- 完全`Python`语言实现，不需要额外依赖，功能稳定

`NLTK:`自然语言文本处理第三方库 - [学习地址](http://www.nltk.org/)

- 提供了一批简单易用的自然语言文本处理功能
- 持语言文本分类、标记、语法句法、语义分析等
- 最优秀的`Python`自然语言处理库

`Python-docx:`创建或更新Microsoft Word文件的第三方库 - [学习地址](http://python-docx.readthedocs.io/en/latest/index.html) 

- 提供创建或更新`.doc` .`docx`等文件的计算功能
- 增加并配置段落、图片、表格、文字等，功能全面

**机器学习**

`Scikit-learn:`机器学习方法工具集 - [学习地址](http://scikit-learn.org/)

- 提供一批统一化的机器学习方法功能接口
- 提供聚类、分类、回归、强化学习等计算功能
- 机器学习最基本且最优秀的`Python`第三方库

`TensorFlow:AlphaGo`背后的机器学习计算框架 - [学习地址](https://www.tensorflow.org/) 

- 谷歌公司推动的开源机器学习框架
- 将数据流图作为基础，图节点代表运算，边代表张量
- 应用机器学习方法的一种方式，支撑谷歌人工智能应用

`MXNet:`基于神经网络的深度学习计算框架 - [学习地址](https://mxnet.incubator.apache.org/) 

- 提供可扩展的神经网络及深度学习计算功能
- 可用于自动驾驶、机器翻译、语音识别等众多领域
- `Python`最重要的深度学习计算框架

### **从Web解析到网络空间**

**网络爬虫**

`Requests:`最友好的网络爬虫功能库 - [学习地址](http://www.python-requests.org/) 

- 提供了简单易用的类HTTP协议网络爬虫功能 
- 支持连接池、`SSL`、`Cookies`、`HTTP(S)`代理等
- `Python`最主要的页面级网络爬虫功能库

`Scrapy: `优秀的网络爬虫框架 - [学习地址](https://scrapy.org/) 

- 提供了构建网络爬虫系统的框架功能，功能半成品 
- 支持批量和定时网页爬取、提供数据处理流程等
- `Python`最主要且最专业的网络爬虫框架

`pyspider:` 强大的`Web`页面爬取系统 - [学习地址](http://docs.pyspider.org/) 

- 提供了完整的网页爬取系统构建功能
- 支持数据库后端、消息队列、优先级、分布式架构等 
- `Python`重要的网络爬虫类第三方库

**Web信息提取**

`Beautiful Soup: `HTML和XML的解析库 - [学习地址](https://www.crummy.com/software/BeautifulSoup/bs4) 

- 提供了解析`HTML`和`XML`等`Web`信息的功能
- 又名`beautifulsoup4`或`bs4`，可以加载多种解析引擎
- 常与网络爬虫库搭配使用，如`Scrapy`、`requests`等

`Re:` 正则表达式解析和处理功能库 - [学习地址](https://docs.python.org/3.6/library/re.html)

- 提供了定义和解析正则表达式的一批通用功能
- 可用于各类场景，包括定点的`Web`信息提取
- `Python`最主要的标准库之一，无需安装

`Python-Goose: `提取文章类型`Web`页面的功能库 - [学习地址](https://github.com/grangier/python-goose)

- 提供了对`Web`页面中文章信息/视频等元数据的提取功能
- 针对特定类型`Web`页面，应用覆盖面较广
-  `Python`最主要的`Web`信息提取库

**Web网站开发**

`Django:` 最流行的`Web`应用框架 - [学习地址](https://www.djangoproject.com/)

- 提供了构建`Web`系统的基本应用框架 
- `MTV`模式：模型`(model)`、模板`(Template)`、视图`(Views)` 
- `Python`最重要的`Web`应用框架，略微复杂的应用框架

`Pyramid:` 规模适中的`Web`应用框架 - [学习地址](https://trypyramid.com/)

- 提供了简单方便构建`Web`系统的应用框架

- 不大不小，规模适中，适合快速构建并适度扩展类应用

- `Python`产品级`Web`应用框架，起步简单可扩展性好

`Flask: Web`应用开发微框架 - [学习地址](http://flask.pocoo.org/)

- 提供了最简单构建`Web`系统的应用框架 
- 特点是：简单、规模小、快速 
- `Django `> `Pyramid `> `Flask`

**网络应用开发**

`WeRoBot`: 微信公众号开发框架 - [学习地址](https://github.com/offu/WeRoBot)

- 提供了解析微信服务器消息及反馈消息的功能
- 建立微信机器人的重要技术手段

`aip`: 百度`AI`开放平台接口 - [学习地址](http://www.python-requests.org/)

- 提供了访问百度AI服务的Python功能接口
- 语音、人脸、`OCR`、`NLP`、知识图谱、图像搜索等领域 
- `Python`百度`AI`应用的最主要方式

`MyQR`: 二维码生成第三方库 - [学习地址](https://github.com/sylnsfar/qrcode)

- 提供了生成二维码的系列功能
- 基本二维码、艺术二维码和动态二维码

### **从人机交互到艺术设计**

**图形用户界面**

`PyQt5: Qt`开发框架的`Python`接口 - [学习地址](https://www.riverbankcomputing.com/software/pyqt)

- 提供了创建`Qt5`程序的`Python API`接口 
- `Qt`是非常成熟的跨平台桌面应用开发系统，完备`GUI `
- 推荐的`Python GUI`开发第三方库

`wxPython:` 跨平台`GUI`开发框架 - [学习地址](https://www.wxpython.org/) 

- 提供了专用于`Python`的跨平台`GUI`开发框架 
- 理解数据类型与索引的关系，操作索引即操作数据
- `Python`最主要的数据分析功能库，基于`Numpy`开发

`PyGObject:` 使用`GTK+`开发`GUI`的功能库 -  [学习地址](https://pygobject.readthedocs.io/) 

- 提供了整合`GTK+`、`WebKitGTK+`等库的功能 
- `GTK+`：跨平台的一种用户图形界面`GUI`框架 
- 实例：`Anaconda`采用该库构建`GUI`

**游戏开发**

`PyGame:` 简单的游戏开发功能库 -  [学习地址](http://www.pygame.org/) 

- 提供了基于`SDL`的简单游戏开发功能及实现引擎
- 理解游戏对外部输入的响应机制及角色构建和交互机制
- `Python`游戏入门最主要的第三方库

`Panda3D: `开源、跨平台的`3D`渲染和游戏开发库 - [学习地址](http://www.panda3d.org/) 

- 一个`3D`游戏引擎，提供`Python`和`C++`两种接口
- 支持很多先进特性：法线贴图、光泽贴图、卡通渲染等
- 由迪士尼和卡尼基梅隆大学共同开发

`cocos2d: `构建`2D`游戏和图形界面交互式应用的框架 - [学习地址](http://python.cocos2d.org/) 

- 提供了基于`OpenGL`的游戏开发图形渲染功能
- 支持`GPU`加速，采用树形结构分层管理游戏对象类型
- 适用于`2D`专业级游戏开发

**虚拟现实**

VR Zero: 在树莓派上开发VR应用的Python库 - [学习地址](https://github.com/WayneKeenan/python-vrzero)

-  提供大量与`VR`开发相关的功能
- 针对树莓派的`VR`开发库，支持设备小型化，配置简单化
- 非常适合初学者实践`VR`开发及应用

`pyovr: Oculus Rift`的`Python`开发接口 - [学习地址](https://github.com/cmbruns/pyovr)

- 针对`Oculus VR`设备的`Python`开发库
- 基于成熟的`VR`设备，提供全套文档，工业级应用设备
- `Python`+虚拟现实领域探索的一种思路

`Vizard: `基于Python的通用VR开发引擎 - [学习地址](http://www.worldviz.com/vizard-virtual-reality-software) 

- 专业的企业级虚拟现实开发引擎 
- 提供详细的官方文档
- 支持多种主流的`VR`硬件设备，具有一定通用

**图形艺术**

`Quads: `迭代的艺术 -  [学习地址](https://github.com/fogleman/Quads)

- 对图片进行四分迭代，形成像素风 
- 可以生成动图或静图图像 - 简单易用，具有很高展示度

`ascii_art: ASCII`艺术库 - [学习地址](https://github.com/jontonsoup4/ascii_art) 

- 普通图片转为`ASCII`艺术风格
- 输出可以是纯文本或彩色文本 - 可采用图片格式输出

`turtle` - [学习地址](https://blog.csdn.net/zengxiantao1994/article/details/76588580/)

- 很流行的绘制图像的函数库
- 在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始，它根据一组函数指令的控制，在这个平面坐标系中移动

```python
# 绘制同切园
import turtle
turtle.pensize(2) # 设置画笔宽度
turtle.circle(10) # 画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆
turtle.circle(40)
turtle.circle(80)
turtle.circle(160)

# 绘制一个五角星
from turtle import *
color('red', 'red') # 设置画笔颜色为red, 填充颜色为red
begin_fill() # 准备开始填充图形
for i in range(5):
    fd(200) # 填充
    rt(144) # 顺时针移动
end_fill()
```



`turtle`

> `turtle`(海龟)库是`turtle`绘图体系的Python实现

> -`turtle`绘图体系：1969年诞生，主要用于程序设计入门
>
> Python语言的标准库之一
>
> 入门级的图形绘制函数库

`turtle.setup`

- 作用：生成一个窗口 or 设置宽度高度
  - 参数1是整数的宽
  - 参数2是整数的高
  - 参数3是整数的起始x轴位置
  - 参数4是整数的起始y轴位置

> 绝对坐标：以画布中间的坐标为锚点，围绕着这个锚点定的坐标
>
> 海龟坐标：以海龟为锚点，海龟前后左右就是相应的前后左右。海龟被创建出来后，头是默认向左。绝对坐标函数无法改变朝向

`turtle.goto`

- 以绝对坐标移动进行移动
  - 参数1是整数的x轴
  - 参数2是整数的y轴

`turtle.bk`

- 让海龟后退运行
  - 参数1是整数的长度

`turtle.fd`

- 让海龟前进
  - 参数1是整数的长度

`turtle.circle`

- 以海龟当前位置左侧的一个点为圆心曲线运行
  - 参数1是整数的圆心
  - 参数2是整数的长度

![image-20210509100254905](/assets/images/2021/2021-05-12-Python/image-20210509100254905.png)

`turtle.seth`

- 以角度坐标来，改变海龟的方向
  - 参数1是整数的度数

`turtle.left`

- 海龟向左旋转角度
  - 参数1是整数的度数

`turtle.right`

- 海龟向右旋转角度
  - 参数1是整数的度数

`turtle.penup`

- 抬起画笔，画笔不在画布上画画，但是可以移动

`turtle.pendown`

- 放下画笔，画笔在抬起后放回画布上画画

`turtle.pensize`

- 设置画笔宽度
  - 别名函数：`turtle.witdh`
  - 参数1是宽度

`turtle.colormod`

- 修改RGB色彩模式
  - 参数1接收1.0则变为RGB小数值模式，接收255则接收RGB证书值模式

`turtle.pencolor`

- 设置画笔颜色
  - 参数1
    - 小写字符串的颜色英文
  - 参数1，参数2， 参数3：三个小数参数的RGB小数值
    - 元组类型的RGB整数值

`turtle.done`

- 程序不自动退出，需要手动关闭窗口

`turtle.write(str, font=("Arial",16， normal))`

- 画出`str`

```python
import turtle
turtle.write('test', font=("Arial",16， normal))
```


```python
import turtle

# 作用：生成一个宽800，高800，起始点在屏幕最左上方的画
turtle.setup(800, 800, 0, 0) 

# 向上移动100
turtle.goto(0, 100)

# 向左转头90度
turtle.left(90)

# 向右转头180度
turtle.right(180)

# 向角度坐标转头90度
turtle.seth(90)

# 设置画笔粗细
turtle.pensize(10)

# 设置画笔颜色为棕色
turtle.pencolor("purple")

# 设置画笔颜色为红色
turtle.pencolor(1, 0, 0)

# 向后移动100
turtle.bk(100)

# 抬起画笔
turtle.penup()

# 向前移动100
turtle.fd(100)

# 放下画笔
turtle.pendown()


# 以左侧的100为圆心移动100
turtle.circle(100, 100)

# 以右侧的100为圆心移动100
turtle.circle(-100, 100)
```





